<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>MdePkg[ALL]: MdePkg/Include/Protocol/FirmwareVolumeBlock.h File Reference</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
<link href="../../tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="../../main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="../../annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="../../files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="../../globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>MdePkg/Include/Protocol/FirmwareVolumeBlock.h File Reference</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dc0/a00033.html">_EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a></td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/de9/a01182.html#634425d0868cfc81406f3ab7eb75c63a">EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL_GUID</a>&nbsp;&nbsp;&nbsp;{ 0xDE28BC59, 0x6228, 0x41BD, {0xBD, 0xF6, 0xA3, 0xB9, 0xAD,0xB5, 0x8D, 0xA1 } }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/de9/a01182.html#41686b428702e1162e8d16507b2c7048">EFI_LBA_LIST_TERMINATOR</a>&nbsp;&nbsp;&nbsp;0xFFFFFFFFFFFFFFFFULL</td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef struct <br class="typebreak">
<a class="el" href="../../d0/dc0/a00033.html">_EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/de9/a01182.html#d7a8ba0805473947f20ff7ca832b884e">EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(EFIAPI *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/de9/a01182.html#e58cdc9bd8781ff4e1bc5dc846fe4f61">EFI_FVB_GET_ATTRIBUTES</a> )(IN CONST <a class="el" href="../../d0/dc0/a00033.html">EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a> *This, OUT <a class="el" href="../../d8/dbf/a01109.html#9c9b8f7e8c5c7ea086f40aca0f74fd02">EFI_FVB_ATTRIBUTES_2</a> *Attributes)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(EFIAPI *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/de9/a01182.html#3dadefdf0d3f90c56933ac60d49cd529">EFI_FVB_SET_ATTRIBUTES</a> )(IN CONST <a class="el" href="../../d0/dc0/a00033.html">EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a> *This, IN OUT <a class="el" href="../../d8/dbf/a01109.html#9c9b8f7e8c5c7ea086f40aca0f74fd02">EFI_FVB_ATTRIBUTES_2</a> *Attributes)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(EFIAPI *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/de9/a01182.html#e033ed923d9ba190ee9dc5fc6315d690">EFI_FVB_GET_PHYSICAL_ADDRESS</a> )(IN CONST <a class="el" href="../../d0/dc0/a00033.html">EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a> *This, OUT <a class="el" href="../../dd/d95/a01247.html#31bc7e7faeab8d2940ee34f21d41cd04">EFI_PHYSICAL_ADDRESS</a> *Address)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(EFIAPI *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/de9/a01182.html#999bc6a5f8ec6ef8aa82d959061db5c5">EFI_FVB_GET_BLOCK_SIZE</a> )(IN CONST <a class="el" href="../../d0/dc0/a00033.html">EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a> *This, IN <a class="el" href="../../dd/d95/a01247.html#3495b0e526b2172f98d5bde00bf28b72">EFI_LBA</a> Lba, OUT <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> *BlockSize, OUT <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> *NumberOfBlocks)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(EFIAPI *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/de9/a01182.html#dd23a316abcf4e4e82bf79fbae025620">EFI_FVB_READ</a> )(IN CONST <a class="el" href="../../d0/dc0/a00033.html">EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a> *This, IN <a class="el" href="../../dd/d95/a01247.html#3495b0e526b2172f98d5bde00bf28b72">EFI_LBA</a> Lba, IN <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> Offset, IN OUT <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> *NumBytes, IN OUT <a class="el" href="../../d0/d90/a01059.html#f3037cbae2cdbc45fb75983c08b87935">UINT8</a> *Buffer)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(EFIAPI *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/de9/a01182.html#418d1ce4d7f68f3f56b590052ba197e2">EFI_FVB_WRITE</a> )(IN CONST <a class="el" href="../../d0/dc0/a00033.html">EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a> *This, IN <a class="el" href="../../dd/d95/a01247.html#3495b0e526b2172f98d5bde00bf28b72">EFI_LBA</a> Lba, IN <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> Offset, IN OUT <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> *NumBytes, IN <a class="el" href="../../d0/d90/a01059.html#f3037cbae2cdbc45fb75983c08b87935">UINT8</a> *Buffer)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(EFIAPI *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/de9/a01182.html#69bd903487e1566d8596d44242c04a17">EFI_FVB_ERASE_BLOCKS</a> )(IN CONST <a class="el" href="../../d0/dc0/a00033.html">EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a> *This,...)</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="../../d1/d87/a00689.html">EFI_GUID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/de9/a01182.html#c7dd22180e12651e972004706585ac43">gEfiFirmwareVolumeBlockProtocolGuid</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This file provides control over block-oriented firmware devices.<p>
Copyright (c) 2006 - 2008, Intel Corporation All rights reserved. This program and the accompanying materials are licensed and made available under the terms and conditions of the BSD License which accompanies this distribution. The full text of the license may be found at <a href="http://opensource.org/licenses/bsd-license.php">http://opensource.org/licenses/bsd-license.php</a><p>
THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.<p>
<dl class="user" compact><dt><b>Revision Reference: PI</b></dt><dd>Version 1.00. </dd></dl>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="634425d0868cfc81406f3ab7eb75c63a"></a><!-- doxytag: member="FirmwareVolumeBlock.h::EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL_GUID" ref="634425d0868cfc81406f3ab7eb75c63a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL_GUID&nbsp;&nbsp;&nbsp;{ 0xDE28BC59, 0x6228, 0x41BD, {0xBD, 0xF6, 0xA3, 0xB9, 0xAD,0xB5, 0x8D, 0xA1 } }          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="41686b428702e1162e8d16507b2c7048"></a><!-- doxytag: member="FirmwareVolumeBlock.h::EFI_LBA_LIST_TERMINATOR" ref="41686b428702e1162e8d16507b2c7048" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_LBA_LIST_TERMINATOR&nbsp;&nbsp;&nbsp;0xFFFFFFFFFFFFFFFFULL          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
EFI_LBA_LIST_TERMINATOR 
</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="d7a8ba0805473947f20ff7ca832b884e"></a><!-- doxytag: member="FirmwareVolumeBlock.h::EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL" ref="d7a8ba0805473947f20ff7ca832b884e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="../../d0/dc0/a00033.html">_EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a> <a class="el" href="../../d0/dc0/a00033.html">EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="69bd903487e1566d8596d44242c04a17"></a><!-- doxytag: member="FirmwareVolumeBlock.h::EFI_FVB_ERASE_BLOCKS" ref="69bd903487e1566d8596d44242c04a17" args=")(IN CONST EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL *This,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(EFIAPI * <a class="el" href="../../dd/de9/a01182.html#69bd903487e1566d8596d44242c04a17">EFI_FVB_ERASE_BLOCKS</a>)(IN CONST <a class="el" href="../../d0/dc0/a00033.html">EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a> *This,...)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erases and initializes a firmware volume block.<p>
The EraseBlocks() function erases one or more blocks as denoted by the variable argument list. The entire parameter list of blocks must be verified before erasing any blocks. If a block is requested that does not exist within the associated firmware volume (it has a larger index than the last block of the firmware volume), the EraseBlocks() function must return the status code EFI_INVALID_PARAMETER without modifying the contents of the firmware volume. Implementations should be mindful that the firmware volume might be in the WriteDisabled state. If it is in this state, the EraseBlocks() function must return the status code EFI_ACCESS_DENIED without modifying the contents of the firmware volume. All calls to EraseBlocks() must be fully flushed to the hardware before the EraseBlocks() service returns.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>This</em>&nbsp;</td><td>Indicates the EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL instance.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td>The variable argument list is a list of tuples. Each tuple describes a range of LBAs to erase and consists of the following:<ul>
<li>An EFI_LBA that indicates the starting LBA</li><li>A UINTN that indicates the number of blocks to erase</li></ul>
</td></tr>
  </table>
</dl>
The list is terminated with an EFI_LBA_LIST_TERMINATOR. For example, the following indicates that two ranges of blocks (5-7 and 10-11) are to be erased: EraseBlocks (This, 5, 3, 10, 2, EFI_LBA_LIST_TERMINATOR);<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EFI_SUCCESS</em>&nbsp;</td><td>The erase request was successfully completed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_ACCESS_DENIED</em>&nbsp;</td><td>The firmware volume is in the WriteDisabled state. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_DEVICE_ERROR</em>&nbsp;</td><td>The block device is not functioning correctly and could not be written. The firmware device may have been partially erased. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_INVALID_PARAMETER</em>&nbsp;</td><td>One or more of the LBAs listed in the variable argument list do not exist in the firmware volume. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e58cdc9bd8781ff4e1bc5dc846fe4f61"></a><!-- doxytag: member="FirmwareVolumeBlock.h::EFI_FVB_GET_ATTRIBUTES" ref="e58cdc9bd8781ff4e1bc5dc846fe4f61" args=")(IN CONST EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL *This, OUT EFI_FVB_ATTRIBUTES_2 *Attributes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(EFIAPI * <a class="el" href="../../dd/de9/a01182.html#e58cdc9bd8781ff4e1bc5dc846fe4f61">EFI_FVB_GET_ATTRIBUTES</a>)(IN CONST <a class="el" href="../../d0/dc0/a00033.html">EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a> *This, OUT <a class="el" href="../../d8/dbf/a01109.html#9c9b8f7e8c5c7ea086f40aca0f74fd02">EFI_FVB_ATTRIBUTES_2</a> *Attributes)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The GetAttributes() function retrieves the attributes and current settings of the block. Status Codes Returned<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>This</em>&nbsp;</td><td>Indicates the EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL instance.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Attributes</em>&nbsp;</td><td>Pointer to EFI_FVB_ATTRIBUTES_2 in which the attributes and current settings are returned. Type EFI_FVB_ATTRIBUTES_2 is defined in <a class="el" href="../../de/d87/a00456.html">EFI_FIRMWARE_VOLUME_HEADER</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EFI_SUCCESS</em>&nbsp;</td><td>The firmware volume attributes were returned. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="999bc6a5f8ec6ef8aa82d959061db5c5"></a><!-- doxytag: member="FirmwareVolumeBlock.h::EFI_FVB_GET_BLOCK_SIZE" ref="999bc6a5f8ec6ef8aa82d959061db5c5" args=")(IN CONST EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL *This, IN EFI_LBA Lba, OUT UINTN *BlockSize, OUT UINTN *NumberOfBlocks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(EFIAPI * <a class="el" href="../../dd/de9/a01182.html#999bc6a5f8ec6ef8aa82d959061db5c5">EFI_FVB_GET_BLOCK_SIZE</a>)(IN CONST <a class="el" href="../../d0/dc0/a00033.html">EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a> *This, IN <a class="el" href="../../dd/d95/a01247.html#3495b0e526b2172f98d5bde00bf28b72">EFI_LBA</a> Lba, OUT <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> *BlockSize, OUT <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> *NumberOfBlocks)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The GetBlockSize() function retrieves the size of the requested block. It also returns the number of additional blocks with the identical size. The GetBlockSize() function is used to retrieve the block map (see <a class="el" href="../../de/d87/a00456.html">EFI_FIRMWARE_VOLUME_HEADER</a>).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>This</em>&nbsp;</td><td>Indicates the EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL instance.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Lba</em>&nbsp;</td><td>Indicates the block for which to return the size.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BlockSize</em>&nbsp;</td><td>Pointer to a caller-allocated UINTN in which the size of the block is returned.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumberOfBlocks</em>&nbsp;</td><td>Pointer to a caller-allocated UINTN in which the number of consecutive blocks, starting with Lba, is returned. All blocks in this range have a size of BlockSize.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EFI_SUCCESS</em>&nbsp;</td><td>The firmware volume base address is returned.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_INVALID_PARAMETER</em>&nbsp;</td><td>The requested LBA is out of range. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e033ed923d9ba190ee9dc5fc6315d690"></a><!-- doxytag: member="FirmwareVolumeBlock.h::EFI_FVB_GET_PHYSICAL_ADDRESS" ref="e033ed923d9ba190ee9dc5fc6315d690" args=")(IN CONST EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL *This, OUT EFI_PHYSICAL_ADDRESS *Address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(EFIAPI * <a class="el" href="../../dd/de9/a01182.html#e033ed923d9ba190ee9dc5fc6315d690">EFI_FVB_GET_PHYSICAL_ADDRESS</a>)(IN CONST <a class="el" href="../../d0/dc0/a00033.html">EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a> *This, OUT <a class="el" href="../../dd/d95/a01247.html#31bc7e7faeab8d2940ee34f21d41cd04">EFI_PHYSICAL_ADDRESS</a> *Address)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The GetPhysicalAddress() function retrieves the base address of a memory-mapped firmware volume. This function should be called only for memory-mapped firmware volumes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>This</em>&nbsp;</td><td>Indicates the EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL instance.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Address</em>&nbsp;</td><td>Pointer to a caller-allocated EFI_PHYSICAL_ADDRESS that, on successful return from GetPhysicalAddress(), contains the base address of the firmware volume.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EFI_SUCCESS</em>&nbsp;</td><td>The firmware volume base address is returned.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_NOT_SUPPORTED</em>&nbsp;</td><td>The firmware volume is not memory mapped. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="dd23a316abcf4e4e82bf79fbae025620"></a><!-- doxytag: member="FirmwareVolumeBlock.h::EFI_FVB_READ" ref="dd23a316abcf4e4e82bf79fbae025620" args=")(IN CONST EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL *This, IN EFI_LBA Lba, IN UINTN Offset, IN OUT UINTN *NumBytes, IN OUT UINT8 *Buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(EFIAPI * <a class="el" href="../../dd/de9/a01182.html#dd23a316abcf4e4e82bf79fbae025620">EFI_FVB_READ</a>)(IN CONST <a class="el" href="../../d0/dc0/a00033.html">EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a> *This, IN <a class="el" href="../../dd/d95/a01247.html#3495b0e526b2172f98d5bde00bf28b72">EFI_LBA</a> Lba, IN <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> Offset, IN OUT <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> *NumBytes, IN OUT <a class="el" href="../../d0/d90/a01059.html#f3037cbae2cdbc45fb75983c08b87935">UINT8</a> *Buffer)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the specified number of bytes into a buffer from the specified block.<p>
The Read() function reads the requested number of bytes from the requested block and stores them in the provided buffer. Implementations should be mindful that the firmware volume might be in the ReadDisabled state. If it is in this state, the Read() function must return the status code EFI_ACCESS_DENIED without modifying the contents of the buffer. The Read() function must also prevent spanning block boundaries. If a read is requested that would span a block boundary, the read must read up to the boundary but not beyond. The output parameter NumBytes must be set to correctly indicate the number of bytes actually read. The caller must be aware that a read may be partially completed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>This</em>&nbsp;</td><td>Indicates the EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL instance.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Lba</em>&nbsp;</td><td>The starting logical block index from which to read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Offset</em>&nbsp;</td><td>Offset into the block at which to begin reading.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBytes</em>&nbsp;</td><td>Pointer to a UINTN. At entry, *NumBytes contains the total size of the buffer. At exit, *NumBytes contains the total number of bytes read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to a caller-allocated buffer that will be used to hold the data that is read.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EFI_SUCCESS</em>&nbsp;</td><td>The firmware volume was read successfully and contents are in Buffer.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_BAD_BUFFER_SIZE</em>&nbsp;</td><td>Read attempted across an LBA boundary. On output, NumBytes contains the total number of bytes returned in Buffer.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_ACCESS_DENIED</em>&nbsp;</td><td>The firmware volume is in the ReadDisabled state.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_DEVICE_ERROR</em>&nbsp;</td><td>The block device is not functioning correctly and could not be read. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3dadefdf0d3f90c56933ac60d49cd529"></a><!-- doxytag: member="FirmwareVolumeBlock.h::EFI_FVB_SET_ATTRIBUTES" ref="3dadefdf0d3f90c56933ac60d49cd529" args=")(IN CONST EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL *This, IN OUT EFI_FVB_ATTRIBUTES_2 *Attributes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(EFIAPI * <a class="el" href="../../dd/de9/a01182.html#3dadefdf0d3f90c56933ac60d49cd529">EFI_FVB_SET_ATTRIBUTES</a>)(IN CONST <a class="el" href="../../d0/dc0/a00033.html">EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a> *This, IN OUT <a class="el" href="../../d8/dbf/a01109.html#9c9b8f7e8c5c7ea086f40aca0f74fd02">EFI_FVB_ATTRIBUTES_2</a> *Attributes)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The SetAttributes() function sets configurable firmware volume attributes and returns the new settings of the firmware volume.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>This</em>&nbsp;</td><td>Indicates the EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL instance.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Attributes</em>&nbsp;</td><td>On input, Attributes is a pointer to EFI_FVB_ATTRIBUTES_2 that contains the desired firmware volume settings. On successful return, it contains the new settings of the firmware volume. Type EFI_FVB_ATTRIBUTES_2 is defined in <a class="el" href="../../de/d87/a00456.html">EFI_FIRMWARE_VOLUME_HEADER</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EFI_SUCCESS</em>&nbsp;</td><td>The firmware volume attributes were returned.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_INVALID_PARAMETER</em>&nbsp;</td><td>The attributes requested are in conflict with the capabilities as declared in the firmware volume header. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="418d1ce4d7f68f3f56b590052ba197e2"></a><!-- doxytag: member="FirmwareVolumeBlock.h::EFI_FVB_WRITE" ref="418d1ce4d7f68f3f56b590052ba197e2" args=")(IN CONST EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL *This, IN EFI_LBA Lba, IN UINTN Offset, IN OUT UINTN *NumBytes, IN UINT8 *Buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(EFIAPI * <a class="el" href="../../dd/de9/a01182.html#418d1ce4d7f68f3f56b590052ba197e2">EFI_FVB_WRITE</a>)(IN CONST <a class="el" href="../../d0/dc0/a00033.html">EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a> *This, IN <a class="el" href="../../dd/d95/a01247.html#3495b0e526b2172f98d5bde00bf28b72">EFI_LBA</a> Lba, IN <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> Offset, IN OUT <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> *NumBytes, IN <a class="el" href="../../d0/d90/a01059.html#f3037cbae2cdbc45fb75983c08b87935">UINT8</a> *Buffer)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the specified number of bytes from the input buffer to the block.<p>
The Write() function writes the specified number of bytes from the provided buffer to the specified block and offset. If the firmware volume is sticky write, the caller must ensure that all the bits of the specified range to write are in the EFI_FVB_ERASE_POLARITY state before calling the Write() function, or else the result will be unpredictable. This unpredictability arises because, for a sticky-write firmware volume, a write may negate a bit in the EFI_FVB_ERASE_POLARITY state but cannot flip it back again. In general, before calling the Write() function, the caller should call the EraseBlocks() function first to erase the specified block to write. A block erase cycle will transition bits from the (NOT)EFI_FVB_ERASE_POLARITY state back to the EFI_FVB_ERASE_POLARITY state. Implementations should be mindful that the firmware volume might be in the WriteDisabled state. If it is in this state, the Write() function must return the status code EFI_ACCESS_DENIED without modifying the contents of the firmware volume. The Write() function must also prevent spanning block boundaries. If a write is requested that spans a block boundary, the write must store up to the boundary but not beyond. The output parameter NumBytes must be set to correctly indicate the number of bytes actually written. The caller must be aware that a write may be partially completed. All writes, partial or otherwise, must be fully flushed to the hardware before the Write() service returns.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>This</em>&nbsp;</td><td>Indicates the EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL instance.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Lba</em>&nbsp;</td><td>The starting logical block index to write to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Offset</em>&nbsp;</td><td>Offset into the block at which to begin writing.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBytes</em>&nbsp;</td><td>Pointer to a UINTN. At entry, *NumBytes contains the total size of the buffer. At exit, *NumBytes contains the total number of bytes actually written.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to a caller-allocated buffer that contains the source for the write.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EFI_SUCCESS</em>&nbsp;</td><td>The firmware volume was written successfully.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_BAD_BUFFER_SIZE</em>&nbsp;</td><td>The write was attempted across an LBA boundary. On output, NumBytes contains the total number of bytes actually written.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_ACCESS_DENIED</em>&nbsp;</td><td>The firmware volume is in the WriteDisabled state.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_DEVICE_ERROR</em>&nbsp;</td><td>The block device is malfunctioning and could not be written. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="c7dd22180e12651e972004706585ac43"></a><!-- doxytag: member="FirmwareVolumeBlock.h::gEfiFirmwareVolumeBlockProtocolGuid" ref="c7dd22180e12651e972004706585ac43" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d87/a00689.html">EFI_GUID</a> <a class="el" href="../../dd/de9/a01182.html#c7dd22180e12651e972004706585ac43">gEfiFirmwareVolumeBlockProtocolGuid</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Aug 7 13:53:33 2009 for MdePkg[ALL] by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>
