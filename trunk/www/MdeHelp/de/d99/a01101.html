<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>MdePkg[ALL]: MdePkg/Include/Library/UefiRuntimeLib.h File Reference</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
<link href="../../tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="../../main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="../../annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="../../files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="../../globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>MdePkg/Include/Library/UefiRuntimeLib.h File Reference</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="../../d0/d90/a01059.html#000dc5dbcb0d4ba7b6f12c577bc56fba">BOOLEAN</a> EFIAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d99/a01101.html#144e22f22cc781f08d172c5c873c1621">EfiAtRuntime</a> (VOID)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="../../d0/d90/a01059.html#000dc5dbcb0d4ba7b6f12c577bc56fba">BOOLEAN</a> EFIAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d99/a01101.html#d2f1dd2c90c1af14a00646f38bd40934">EfiGoneVirtual</a> (VOID)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> EFIAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d99/a01101.html#e509606bd75e3b6c4a9e3f16a2ef01c7">EfiGetTime</a> (OUT <a class="el" href="../../dc/df1/a00662.html">EFI_TIME</a> *Time, OUT <a class="el" href="../../d7/d5f/a00663.html">EFI_TIME_CAPABILITIES</a> *Capabilities)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> EFIAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d99/a01101.html#6460af28def16922e42ee44d68473986">EfiSetTime</a> (IN <a class="el" href="../../dc/df1/a00662.html">EFI_TIME</a> *Time)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> EFIAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d99/a01101.html#903a559e905a35745cfb2e71d32be4f0">EfiGetWakeupTime</a> (OUT <a class="el" href="../../d0/d90/a01059.html#000dc5dbcb0d4ba7b6f12c577bc56fba">BOOLEAN</a> *Enabled, OUT <a class="el" href="../../d0/d90/a01059.html#000dc5dbcb0d4ba7b6f12c577bc56fba">BOOLEAN</a> *Pending, OUT <a class="el" href="../../dc/df1/a00662.html">EFI_TIME</a> *Time)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> EFIAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d99/a01101.html#79f24bcdeb622929236aff2d3b986965">EfiSetWakeupTime</a> (IN <a class="el" href="../../d0/d90/a01059.html#000dc5dbcb0d4ba7b6f12c577bc56fba">BOOLEAN</a> Enable, IN <a class="el" href="../../dc/df1/a00662.html">EFI_TIME</a> *Time)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> EFIAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d99/a01101.html#cb5e6bf3ea432a2f3300e67b3484a6df">EfiGetVariable</a> (IN <a class="el" href="../../d0/d90/a01059.html#8a79e1974f247348d08f0ad87ccfe7a4">CHAR16</a> *VariableName, IN <a class="el" href="../../d1/d87/a00689.html">EFI_GUID</a> *VendorGuid, OUT <a class="el" href="../../d0/d90/a01059.html#dfe04a44baaebba6143c3a23507ff85b">UINT32</a> *Attributes, IN OUT <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> *DataSize, OUT VOID *Data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> EFIAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d99/a01101.html#10e9819da6e1910e4bacc572760ce558">EfiGetNextVariableName</a> (IN OUT <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> *VariableNameSize, IN OUT <a class="el" href="../../d0/d90/a01059.html#8a79e1974f247348d08f0ad87ccfe7a4">CHAR16</a> *VariableName, IN OUT <a class="el" href="../../d1/d87/a00689.html">EFI_GUID</a> *VendorGuid)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> EFIAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d99/a01101.html#ac887fb599a14124c69a644f9319cd72">EfiSetVariable</a> (IN <a class="el" href="../../d0/d90/a01059.html#8a79e1974f247348d08f0ad87ccfe7a4">CHAR16</a> *VariableName, IN <a class="el" href="../../d1/d87/a00689.html">EFI_GUID</a> *VendorGuid, IN <a class="el" href="../../d0/d90/a01059.html#dfe04a44baaebba6143c3a23507ff85b">UINT32</a> Attributes, IN <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> DataSize, IN VOID *Data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> EFIAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d99/a01101.html#a05f6e309766efde1998ad951d473ad2">EfiGetNextHighMonotonicCount</a> (OUT <a class="el" href="../../d0/d90/a01059.html#dfe04a44baaebba6143c3a23507ff85b">UINT32</a> *HighCount)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID EFIAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d99/a01101.html#9d43375098ff4e2a9ee0d0dc3c4edd5f">EfiResetSystem</a> (IN <a class="el" href="../../d0/d33/a01252.html#ac10574bc0f1e0c24b051d55eb572b49">EFI_RESET_TYPE</a> ResetType, IN <a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> ResetStatus, IN <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> DataSize, IN VOID *ResetData)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> EFIAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d99/a01101.html#8f390563b05c37c3e189e3223a757935">EfiConvertPointer</a> (IN <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> DebugDisposition, IN OUT VOID **Address)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> EFIAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d99/a01101.html#e5a7981761c73c4627850a39cae0a0f5">EfiConvertFunctionPointer</a> (IN <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> DebugDisposition, IN OUT VOID **Address)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> EFIAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d99/a01101.html#a8c1a0abf86088c2f3346391ad2e1ed7">EfiSetVirtualAddressMap</a> (IN <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> MemoryMapSize, IN <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> DescriptorSize, IN <a class="el" href="../../d0/d90/a01059.html#dfe04a44baaebba6143c3a23507ff85b">UINT32</a> DescriptorVersion, IN CONST <a class="el" href="../../dc/df9/a00554.html">EFI_MEMORY_DESCRIPTOR</a> *VirtualMap)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> EFIAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d99/a01101.html#ae179e0b1edd13b816b8a2742e34f185">EfiConvertList</a> (IN <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> DebugDisposition, IN OUT <a class="el" href="../../dc/d5d/a00278.html">LIST_ENTRY</a> *ListHead)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> EFIAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d99/a01101.html#3ab21568c6aae668cb3e75770f6ccb47">EfiUpdateCapsule</a> (IN <a class="el" href="../../d8/d91/a00410.html">EFI_CAPSULE_HEADER</a> **CapsuleHeaderArray, IN <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> CapsuleCount, IN <a class="el" href="../../dd/d95/a01247.html#31bc7e7faeab8d2940ee34f21d41cd04">EFI_PHYSICAL_ADDRESS</a> ScatterGatherList)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> EFIAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d99/a01101.html#c404eaac5cae1bd262f01e14caabd2c5">EfiQueryCapsuleCapabilities</a> (IN <a class="el" href="../../d8/d91/a00410.html">EFI_CAPSULE_HEADER</a> **CapsuleHeaderArray, IN <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> CapsuleCount, OUT <a class="el" href="../../d0/d90/a01059.html#95df6cdb32afc350ff070f2fe8a54a67">UINT64</a> *MaximumCapsuleSize, OUT <a class="el" href="../../d0/d33/a01252.html#ac10574bc0f1e0c24b051d55eb572b49">EFI_RESET_TYPE</a> *ResetType)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> EFIAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d99/a01101.html#d5f5f5f1b9d426255f04601c2146058f">EfiQueryVariableInfo</a> (IN <a class="el" href="../../d0/d90/a01059.html#dfe04a44baaebba6143c3a23507ff85b">UINT32</a> Attributes, OUT <a class="el" href="../../d0/d90/a01059.html#95df6cdb32afc350ff070f2fe8a54a67">UINT64</a> *MaximumVariableStorageSize, OUT <a class="el" href="../../d0/d90/a01059.html#95df6cdb32afc350ff070f2fe8a54a67">UINT64</a> *RemainingVariableStorageSize, OUT <a class="el" href="../../d0/d90/a01059.html#95df6cdb32afc350ff070f2fe8a54a67">UINT64</a> *MaximumVariableSize)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Provides library functions for each of the UEFI Runtime Services. Only available to DXE and UEFI module types.<p>
Copyright (c) 2006 - 2008, Intel Corporation<br>
 All rights reserved. This program and the accompanying materials are licensed and made available under the terms and conditions of the BSD License which accompanies this distribution. The full text of the license may be found at <a href="http://opensource.org/licenses/bsd-license.php">http://opensource.org/licenses/bsd-license.php</a><p>
THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED. <hr><h2>Function Documentation</h2>
<a class="anchor" name="144e22f22cc781f08d172c5c873c1621"></a><!-- doxytag: member="UefiRuntimeLib.h::EfiAtRuntime" ref="144e22f22cc781f08d172c5c873c1621" args="(VOID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d90/a01059.html#000dc5dbcb0d4ba7b6f12c577bc56fba">BOOLEAN</a> EFIAPI EfiAtRuntime           </td>
          <td>(</td>
          <td class="paramtype">VOID&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function allows the caller to determine if UEFI ExitBootServices() has been called.<p>
This function returns TRUE after all the EVT_SIGNAL_EXIT_BOOT_SERVICES functions have executed as a result of the OS calling ExitBootServices(). Prior to this time FALSE is returned. This function is used by runtime code to decide it is legal to access services that go away after ExitBootServices().<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>TRUE</em>&nbsp;</td><td>The system has finished executing the EVT_SIGNAL_EXIT_BOOT_SERVICES event. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FALSE</em>&nbsp;</td><td>The system has not finished executing the EVT_SIGNAL_EXIT_BOOT_SERVICES event. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e5a7981761c73c4627850a39cae0a0f5"></a><!-- doxytag: member="UefiRuntimeLib.h::EfiConvertFunctionPointer" ref="e5a7981761c73c4627850a39cae0a0f5" args="(IN UINTN DebugDisposition, IN OUT VOID **Address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> EFIAPI EfiConvertFunctionPointer           </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a>&nbsp;</td>
          <td class="paramname"> <em>DebugDisposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN OUT VOID **&nbsp;</td>
          <td class="paramname"> <em>Address</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines the new virtual address that is to be used on subsequent memory accesses.<p>
For IA32, x64, and EBC, this service is a wrapper for the UEFI Runtime Service ConvertPointer(). See the UEFI Specification for details. For IPF, this function interprets Address as a pointer to an <a class="el" href="../../d5/d8a/a00599.html">EFI_PLABEL</a> structure and both the EntryPoint and GP fields of an <a class="el" href="../../d5/d8a/a00599.html">EFI_PLABEL</a> are converted from physical to virtiual addressing. Since IPF allows the GP to point to an address outside a PE/COFF image, the physical to virtual offset for the EntryPoint field is used to adjust the GP field. The UEFI Runtime Service ConvertPointer() is used to convert EntryPoint and the status code for this conversion is always returned. If the convertion of EntryPoint fails, then neither EntryPoint nor GP are modified. See the UEFI Specification for details on the UEFI Runtime Service ConvertPointer().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DebugDisposition</em>&nbsp;</td><td>Supplies type information for the pointer being converted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Address</em>&nbsp;</td><td>The pointer to a pointer that is to be fixed to be the value needed for the new virtual address mapping being applied.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>EFI_STATUS value from <a class="el" href="../../de/d99/a01101.html#8f390563b05c37c3e189e3223a757935">EfiConvertPointer()</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ae179e0b1edd13b816b8a2742e34f185"></a><!-- doxytag: member="UefiRuntimeLib.h::EfiConvertList" ref="ae179e0b1edd13b816b8a2742e34f185" args="(IN UINTN DebugDisposition, IN OUT LIST_ENTRY *ListHead)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> EFIAPI EfiConvertList           </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a>&nbsp;</td>
          <td class="paramname"> <em>DebugDisposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN OUT <a class="el" href="../../dc/d5d/a00278.html">LIST_ENTRY</a> *&nbsp;</td>
          <td class="paramname"> <em>ListHead</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert the standard Lib double linked list to a virtual mapping.<p>
This service uses <a class="el" href="../../de/d99/a01101.html#8f390563b05c37c3e189e3223a757935">EfiConvertPointer()</a> to walk a double linked list and convert all the link pointers to their virtual mappings. This function is only guaranteed to work during the EVT_SIGNAL_VIRTUAL_ADDRESS_CHANGE event and calling it at other times has undefined results.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DebugDisposition</em>&nbsp;</td><td>Supplies type information for the pointer being converted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ListHead</em>&nbsp;</td><td>Head of linked list to convert.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EFI_SUCCESS</em>&nbsp;</td><td>Success to execute the function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>!EFI_SUCCESS</em>&nbsp;</td><td>Failed to execute the function. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8f390563b05c37c3e189e3223a757935"></a><!-- doxytag: member="UefiRuntimeLib.h::EfiConvertPointer" ref="8f390563b05c37c3e189e3223a757935" args="(IN UINTN DebugDisposition, IN OUT VOID **Address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> EFIAPI EfiConvertPointer           </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a>&nbsp;</td>
          <td class="paramname"> <em>DebugDisposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN OUT VOID **&nbsp;</td>
          <td class="paramname"> <em>Address</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This service is a wrapper for the UEFI Runtime Service ConvertPointer().<p>
The ConvertPointer() function is used by an EFI component during the SetVirtualAddressMap() operation. ConvertPointer()must be called using physical address pointers during the execution of SetVirtualAddressMap().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DebugDisposition</em>&nbsp;</td><td>Supplies type information for the pointer being converted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Address</em>&nbsp;</td><td>The pointer to a pointer that is to be fixed to be the value needed for the new virtual address mapping being applied.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EFI_SUCCESS</em>&nbsp;</td><td>The pointer pointed to by Address was modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_NOT_FOUND</em>&nbsp;</td><td>The pointer pointed to by Address was not found to be part of the current memory map. This is normally fatal. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_INVALID_PARAMETER</em>&nbsp;</td><td>Address is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_INVALID_PARAMETER</em>&nbsp;</td><td>*Address is NULL and DebugDispositio </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a05f6e309766efde1998ad951d473ad2"></a><!-- doxytag: member="UefiRuntimeLib.h::EfiGetNextHighMonotonicCount" ref="a05f6e309766efde1998ad951d473ad2" args="(OUT UINT32 *HighCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> EFIAPI EfiGetNextHighMonotonicCount           </td>
          <td>(</td>
          <td class="paramtype">OUT <a class="el" href="../../d0/d90/a01059.html#dfe04a44baaebba6143c3a23507ff85b">UINT32</a> *&nbsp;</td>
          <td class="paramname"> <em>HighCount</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This service is a wrapper for the UEFI Runtime Service GetNextHighMonotonicCount().<p>
The platform's monotonic counter is comprised of two 32-bit quantities: the high 32 bits and the low 32 bits. During boot service time the low 32-bit value is volatile: it is reset to zero on every system reset and is increased by 1 on every call to GetNextMonotonicCount(). The high 32-bit value is nonvolatile and is increased by 1 whenever the system resets or whenever the low 32-bit count (returned by GetNextMonoticCount()) overflows.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>HighCount</em>&nbsp;</td><td>Pointer to returned value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EFI_SUCCESS</em>&nbsp;</td><td>The next high monotonic count was returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_DEVICE_ERROR</em>&nbsp;</td><td>The device is not functioning properly. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_INVALID_PARAMETER</em>&nbsp;</td><td>HighCount is NULL. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="10e9819da6e1910e4bacc572760ce558"></a><!-- doxytag: member="UefiRuntimeLib.h::EfiGetNextVariableName" ref="10e9819da6e1910e4bacc572760ce558" args="(IN OUT UINTN *VariableNameSize, IN OUT CHAR16 *VariableName, IN OUT EFI_GUID *VendorGuid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> EFIAPI EfiGetNextVariableName           </td>
          <td>(</td>
          <td class="paramtype">IN OUT <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> *&nbsp;</td>
          <td class="paramname"> <em>VariableNameSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN OUT <a class="el" href="../../d0/d90/a01059.html#8a79e1974f247348d08f0ad87ccfe7a4">CHAR16</a> *&nbsp;</td>
          <td class="paramname"> <em>VariableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN OUT <a class="el" href="../../d1/d87/a00689.html">EFI_GUID</a> *&nbsp;</td>
          <td class="paramname"> <em>VendorGuid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This service is a wrapper for the UEFI Runtime Service GetNextVariableName().<p>
GetNextVariableName() is called multiple times to retrieve the VariableName and VendorGuid of all variables currently available in the system. On each call to GetNextVariableName() the previous results are passed into the interface, and on output the interface returns the next variable name data. When the entire variable list has been returned, the error EFI_NOT_FOUND is returned.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>VariableNameSize</em>&nbsp;</td><td>As input, point to maximum size of variable name. As output, point to actual size of variable name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VariableName</em>&nbsp;</td><td>As input, supplies the last VariableName that was returned by GetNextVariableName(). As output, returns the name of variable. The name string is Null-Terminated Unicode string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VendorGuid</em>&nbsp;</td><td>As input, supplies the last VendorGuid that was returned by GetNextVriableName(). As output, returns the VendorGuid of the current variable.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EFI_SUCCESS</em>&nbsp;</td><td>The function completed successfully. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_NOT_FOUND</em>&nbsp;</td><td>The next variable was not found. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_BUFFER_TOO_SMALL</em>&nbsp;</td><td>The VariableNameSize is too small for the result. VariableNameSize has been updated with the size needed to complete the request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_INVALID_PARAMETER</em>&nbsp;</td><td>VariableNameSize is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_INVALID_PARAMETER</em>&nbsp;</td><td>VariableName is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_INVALID_PARAMETER</em>&nbsp;</td><td>VendorGuid is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_DEVICE_ERROR</em>&nbsp;</td><td>The variable name could not be retrieved due to a hardware error. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e509606bd75e3b6c4a9e3f16a2ef01c7"></a><!-- doxytag: member="UefiRuntimeLib.h::EfiGetTime" ref="e509606bd75e3b6c4a9e3f16a2ef01c7" args="(OUT EFI_TIME *Time, OUT EFI_TIME_CAPABILITIES *Capabilities)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> EFIAPI EfiGetTime           </td>
          <td>(</td>
          <td class="paramtype">OUT <a class="el" href="../../dc/df1/a00662.html">EFI_TIME</a> *&nbsp;</td>
          <td class="paramname"> <em>Time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="../../d7/d5f/a00663.html">EFI_TIME_CAPABILITIES</a> *&nbsp;</td>
          <td class="paramname"> <em>Capabilities</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This service is a wrapper for the UEFI Runtime Service GetTime().<p>
The GetTime() function returns a time that was valid sometime during the call to the function. While the returned <a class="el" href="../../dc/df1/a00662.html">EFI_TIME</a> structure contains TimeZone and Daylight savings time information, the actual clock does not maintain these values. The current time zone and daylight saving time information returned by GetTime() are the values that were last set via SetTime(). The GetTime() function should take approximately the same amount of time to read the time each time it is called. All reported device capabilities are to be rounded up. During runtime, if a PC-AT CMOS device is present in the platform, the caller must synchronize access to the device before calling GetTime().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Time</em>&nbsp;</td><td>A pointer to storage to receive a snapshot of the current time. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Capabilities</em>&nbsp;</td><td>An optional pointer to a buffer to receive the real time clock device's capabilities.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EFI_SUCCESS</em>&nbsp;</td><td>The operation completed successfully. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_INVALID_PARAMETER</em>&nbsp;</td><td>Time is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_DEVICE_ERROR</em>&nbsp;</td><td>The time could not be retrieved due to a hardware error. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cb5e6bf3ea432a2f3300e67b3484a6df"></a><!-- doxytag: member="UefiRuntimeLib.h::EfiGetVariable" ref="cb5e6bf3ea432a2f3300e67b3484a6df" args="(IN CHAR16 *VariableName, IN EFI_GUID *VendorGuid, OUT UINT32 *Attributes, IN OUT UINTN *DataSize, OUT VOID *Data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> EFIAPI EfiGetVariable           </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="../../d0/d90/a01059.html#8a79e1974f247348d08f0ad87ccfe7a4">CHAR16</a> *&nbsp;</td>
          <td class="paramname"> <em>VariableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="../../d1/d87/a00689.html">EFI_GUID</a> *&nbsp;</td>
          <td class="paramname"> <em>VendorGuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="../../d0/d90/a01059.html#dfe04a44baaebba6143c3a23507ff85b">UINT32</a> *&nbsp;</td>
          <td class="paramname"> <em>Attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN OUT <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> *&nbsp;</td>
          <td class="paramname"> <em>DataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT VOID *&nbsp;</td>
          <td class="paramname"> <em>Data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This service is a wrapper for the UEFI Runtime Service <a class="el" href="../../d3/dbd/a01100.html#271f3e023dee65a16e84147d7325d786">GetVariable()</a>.<p>
Each vendor may create and manage its own variables without the risk of name conflicts by using a unique VendorGuid. When a variable is set, its Attributes are supplied to indicate how the data variable should be stored and maintained by the system. The attributes affect when the variable may be accessed and volatility of the data. Any attempts to access a variable that does not have the attribute set for runtime access will yield the EFI_NOT_FOUND error. If the Data buffer is too small to hold the contents of the variable, the error EFI_BUFFER_TOO_SMALL is returned and DataSize is set to the required buffer size to obtain the data.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>VariableName</em>&nbsp;</td><td>the name of the vendor's variable, it's a Null-Terminated Unicode String </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VendorGuid</em>&nbsp;</td><td>Unify identifier for vendor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Attributes</em>&nbsp;</td><td>Point to memory location to return the attributes of variable. If the point is NULL, the parameter would be ignored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DataSize</em>&nbsp;</td><td>As input, point to the maximum size of return Data-Buffer. As output, point to the actual size of the returned Data-Buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>Point to return Data-Buffer.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EFI_SUCCESS</em>&nbsp;</td><td>The function completed successfully. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_NOT_FOUND</em>&nbsp;</td><td>The variable was not found. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_BUFFER_TOO_SMALL</em>&nbsp;</td><td>The DataSize is too small for the result. DataSize has been updated with the size needed to complete the request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_INVALID_PARAMETER</em>&nbsp;</td><td>VariableName is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_INVALID_PARAMETER</em>&nbsp;</td><td>VendorGuid is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_INVALID_PARAMETER</em>&nbsp;</td><td>DataSize is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_INVALID_PARAMETER</em>&nbsp;</td><td>The DataSize is not too small and Data is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_DEVICE_ERROR</em>&nbsp;</td><td>The variable could not be retrieved due to a hardware error. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_SECURITY_VIOLATION</em>&nbsp;</td><td>The variable could not be retrieved due to an authentication failure. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="903a559e905a35745cfb2e71d32be4f0"></a><!-- doxytag: member="UefiRuntimeLib.h::EfiGetWakeupTime" ref="903a559e905a35745cfb2e71d32be4f0" args="(OUT BOOLEAN *Enabled, OUT BOOLEAN *Pending, OUT EFI_TIME *Time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> EFIAPI EfiGetWakeupTime           </td>
          <td>(</td>
          <td class="paramtype">OUT <a class="el" href="../../d0/d90/a01059.html#000dc5dbcb0d4ba7b6f12c577bc56fba">BOOLEAN</a> *&nbsp;</td>
          <td class="paramname"> <em>Enabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="../../d0/d90/a01059.html#000dc5dbcb0d4ba7b6f12c577bc56fba">BOOLEAN</a> *&nbsp;</td>
          <td class="paramname"> <em>Pending</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="../../dc/df1/a00662.html">EFI_TIME</a> *&nbsp;</td>
          <td class="paramname"> <em>Time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This service is a wrapper for the UEFI Runtime Service GetWakeupTime().<p>
The alarm clock time may be rounded from the set alarm clock time to be within the resolution of the alarm clock device. The resolution of the alarm clock device is defined to be one second. During runtime, if a PC-AT CMOS device is present in the platform the caller must synchronize access to the device before calling GetWakeupTime().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Enabled</em>&nbsp;</td><td>Indicates if the alarm is currently enabled or disabled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Pending</em>&nbsp;</td><td>Indicates if the alarm signal is pending and requires acknowledgement. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Time</em>&nbsp;</td><td>The current alarm setting. Type <a class="el" href="../../dc/df1/a00662.html">EFI_TIME</a> is defined in the GetTime() function description.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EFI_SUCCESS</em>&nbsp;</td><td>The alarm settings were returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_INVALID_PARAMETER</em>&nbsp;</td><td>Enabled is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_INVALID_PARAMETER</em>&nbsp;</td><td>Pending is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_INVALID_PARAMETER</em>&nbsp;</td><td>Time is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_DEVICE_ERROR</em>&nbsp;</td><td>The wakeup time could not be retrieved due to a hardware error. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_UNSUPPORTED</em>&nbsp;</td><td>A wakeup timer is not supported on this platform. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d2f1dd2c90c1af14a00646f38bd40934"></a><!-- doxytag: member="UefiRuntimeLib.h::EfiGoneVirtual" ref="d2f1dd2c90c1af14a00646f38bd40934" args="(VOID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d90/a01059.html#000dc5dbcb0d4ba7b6f12c577bc56fba">BOOLEAN</a> EFIAPI EfiGoneVirtual           </td>
          <td>(</td>
          <td class="paramtype">VOID&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function allows the caller to determine if UEFI SetVirtualAddressMap() has been called.<p>
This function returns TRUE after all the EVT_SIGNAL_VIRTUAL_ADDRESS_CHANGE functions have executed as a result of the OS calling SetVirtualAddressMap(). Prior to this time FALSE is returned. This function is used by runtime code to decide it is legal to access services that go away after SetVirtualAddressMap().<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>TRUE</em>&nbsp;</td><td>The system has finished executing the EVT_SIGNAL_VIRTUAL_ADDRESS_CHANGE event. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FALSE</em>&nbsp;</td><td>The system has not finished executing the EVT_SIGNAL_VIRTUAL_ADDRESS_CHANGE event. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c404eaac5cae1bd262f01e14caabd2c5"></a><!-- doxytag: member="UefiRuntimeLib.h::EfiQueryCapsuleCapabilities" ref="c404eaac5cae1bd262f01e14caabd2c5" args="(IN EFI_CAPSULE_HEADER **CapsuleHeaderArray, IN UINTN CapsuleCount, OUT UINT64 *MaximumCapsuleSize, OUT EFI_RESET_TYPE *ResetType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> EFIAPI EfiQueryCapsuleCapabilities           </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="../../d8/d91/a00410.html">EFI_CAPSULE_HEADER</a> **&nbsp;</td>
          <td class="paramname"> <em>CapsuleHeaderArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a>&nbsp;</td>
          <td class="paramname"> <em>CapsuleCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="../../d0/d90/a01059.html#95df6cdb32afc350ff070f2fe8a54a67">UINT64</a> *&nbsp;</td>
          <td class="paramname"> <em>MaximumCapsuleSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="../../d0/d33/a01252.html#ac10574bc0f1e0c24b051d55eb572b49">EFI_RESET_TYPE</a> *&nbsp;</td>
          <td class="paramname"> <em>ResetType</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This service is a wrapper for the UEFI Runtime Service QueryCapsuleCapabilities().<p>
The QueryCapsuleCapabilities() function allows a caller to test to see if a capsule or capsules can be updated via UpdateCapsule(). The Flags values in the capsule header and size of the entire capsule is checked. If the caller needs to query for generic capsule capability a fake <a class="el" href="../../d8/d91/a00410.html">EFI_CAPSULE_HEADER</a> can be constructed where CapsuleImageSize is equal to HeaderSize that is equal to sizeof (<a class="el" href="../../d8/d91/a00410.html">EFI_CAPSULE_HEADER</a>). To determine reset requirements, CAPSULE_FLAGS_PERSIST_ACROSS_RESET should be set in the Flags field of the <a class="el" href="../../d8/d91/a00410.html">EFI_CAPSULE_HEADER</a>. The firmware must support any capsule that has the CAPSULE_FLAGS_PERSIST_ACROSS_RESET flag set in <a class="el" href="../../d8/d91/a00410.html">EFI_CAPSULE_HEADER</a>. The firmware sets the policy for what capsules are supported that do not have the CAPSULE_FLAGS_PERSIST_ACROSS_RESET flag set.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CapsuleHeaderArray</em>&nbsp;</td><td>Virtual pointer to an array of virtual pointers to the capsules being passed into update capsule. The capsules are assumed to stored in contiguous virtual memory. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CapsuleCount</em>&nbsp;</td><td>Number of pointers to <a class="el" href="../../d8/d91/a00410.html">EFI_CAPSULE_HEADER</a> in CaspuleHeaderArray. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MaximumCapsuleSize</em>&nbsp;</td><td>On output the maximum size that UpdateCapsule() can support as an argument to UpdateCapsule() via CapsuleHeaderArray and ScatterGatherList. Undefined on input. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ResetType</em>&nbsp;</td><td>Returns the type of reset required for the capsule update.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EFI_SUCCESS</em>&nbsp;</td><td>Valid answer returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_INVALID_PARAMETER</em>&nbsp;</td><td>MaximumCapsuleSize is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_UNSUPPORTED</em>&nbsp;</td><td>The capsule type is not supported on this platform, and MaximumCapsuleSize and ResetType are undefined. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_OUT_OF_RESOURCES</em>&nbsp;</td><td>There were insufficient resources to process the query request. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d5f5f5f1b9d426255f04601c2146058f"></a><!-- doxytag: member="UefiRuntimeLib.h::EfiQueryVariableInfo" ref="d5f5f5f1b9d426255f04601c2146058f" args="(IN UINT32 Attributes, OUT UINT64 *MaximumVariableStorageSize, OUT UINT64 *RemainingVariableStorageSize, OUT UINT64 *MaximumVariableSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> EFIAPI EfiQueryVariableInfo           </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="../../d0/d90/a01059.html#dfe04a44baaebba6143c3a23507ff85b">UINT32</a>&nbsp;</td>
          <td class="paramname"> <em>Attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="../../d0/d90/a01059.html#95df6cdb32afc350ff070f2fe8a54a67">UINT64</a> *&nbsp;</td>
          <td class="paramname"> <em>MaximumVariableStorageSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="../../d0/d90/a01059.html#95df6cdb32afc350ff070f2fe8a54a67">UINT64</a> *&nbsp;</td>
          <td class="paramname"> <em>RemainingVariableStorageSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="../../d0/d90/a01059.html#95df6cdb32afc350ff070f2fe8a54a67">UINT64</a> *&nbsp;</td>
          <td class="paramname"> <em>MaximumVariableSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This service is a wrapper for the UEFI Runtime Service QueryVariableInfo().<p>
The QueryVariableInfo() function allows a caller to obtain the information about the maximum size of the storage space available for the EFI variables, the remaining size of the storage space available for the EFI variables and the maximum size of each individual EFI variable, associated with the attributes specified. The returned MaximumVariableStorageSize, RemainingVariableStorageSize, MaximumVariableSize information may change immediately after the call based on other runtime activities including asynchronous error events. Also, these values associated with different attributes are not additive in nature.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Attributes</em>&nbsp;</td><td>Attributes bitmask to specify the type of variables on which to return information. Refer to the <a class="el" href="../../d3/dbd/a01100.html#271f3e023dee65a16e84147d7325d786">GetVariable()</a> function description. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MaximumVariableStorageSize</em>&nbsp;</td><td>On output the maximum size of the storage space available for the EFI variables associated with the attributes specified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RemainingVariableStorageSize</em>&nbsp;</td><td>Returns the remaining size of the storage space available for the EFI variables associated with the attributes specified.. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MaximumVariableSize</em>&nbsp;</td><td>Returns the maximum size of the individual EFI variables associated with the attributes specified.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EFI_SUCCESS</em>&nbsp;</td><td>Valid answer returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_INVALID_PARAMETER</em>&nbsp;</td><td>An invalid combination of attribute bits was supplied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_UNSUPPORTED</em>&nbsp;</td><td>EFI_UNSUPPORTED The attribute is not supported on this platform, and the MaximumVariableStorageSize, RemainingVariableStorageSize, MaximumVariableSize are undefined. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9d43375098ff4e2a9ee0d0dc3c4edd5f"></a><!-- doxytag: member="UefiRuntimeLib.h::EfiResetSystem" ref="9d43375098ff4e2a9ee0d0dc3c4edd5f" args="(IN EFI_RESET_TYPE ResetType, IN EFI_STATUS ResetStatus, IN UINTN DataSize, IN VOID *ResetData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID EFIAPI EfiResetSystem           </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="../../d0/d33/a01252.html#ac10574bc0f1e0c24b051d55eb572b49">EFI_RESET_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>ResetType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>&nbsp;</td>
          <td class="paramname"> <em>ResetStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a>&nbsp;</td>
          <td class="paramname"> <em>DataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN VOID *&nbsp;</td>
          <td class="paramname"> <em>ResetData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This service is a wrapper for the UEFI Runtime Service ResetSystem().<p>
The ResetSystem()function resets the entire platform, including all processors and devices,and reboots the system. Calling this interface with ResetType of EfiResetCold causes a system-wide reset. This sets all circuitry within the system to its initial state. This type of reset is asynchronous to system operation and operates without regard to cycle boundaries. EfiResetCold is tantamount to a system power cycle. Calling this interface with ResetType of EfiResetWarm causes a system-wide initialization. The processors are set to their initial state, and pending cycles are not corrupted. If the system does not support this reset type, then an EfiResetCold must be performed. Calling this interface with ResetType of EfiResetShutdown causes the system to enter a power state equivalent to the ACPI G2/S5 or G3 states. If the system does not support this reset type, then when the system is rebooted, it should exhibit the EfiResetCold attributes. The platform may optionally log the parameters from any non-normal reset that occurs. The ResetSystem() function does not return.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ResetType</em>&nbsp;</td><td>The type of reset to perform. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ResetStatus</em>&nbsp;</td><td>The status code for the reset. If the system reset is part of a normal operation, the status code would be EFI_SUCCESS. If the system reset is due to some type of failure the most appropriate EFI Status code would be used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DataSizeThe</em>&nbsp;</td><td>size, in bytes, of ResetData. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ResetData</em>&nbsp;</td><td>For a ResetType of EfiResetCold, EfiResetWarm, or EfiResetShutdown the data buffer starts with a Null-terminated Unicode string, optionally followed by additional binary data. The string is a description that the caller may use to further indicate the reason for the system reset. ResetData is only valid if ResetStatus is something other then EFI_SUCCESS. This pointer must be a physical address. For a ResetType of EfiRestUpdate the data buffer also starts with a Null-terminated string that is followed by a physical VOID * to an <a class="el" href="../../d8/d91/a00410.html">EFI_CAPSULE_HEADER</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6460af28def16922e42ee44d68473986"></a><!-- doxytag: member="UefiRuntimeLib.h::EfiSetTime" ref="6460af28def16922e42ee44d68473986" args="(IN EFI_TIME *Time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> EFIAPI EfiSetTime           </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="../../dc/df1/a00662.html">EFI_TIME</a> *&nbsp;</td>
          <td class="paramname"> <em>Time</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This service is a wrapper for the UEFI Runtime Service SetTime().<p>
The SetTime() function sets the real time clock device to the supplied time, and records the current time zone and daylight savings time information. The SetTime() function is not allowed to loop based on the current time. For example, if the device does not support a hardware reset for the sub-resolution time, the code is not to implement the feature by waiting for the time to wrap. During runtime, if a PC-AT CMOS device is present in the platform, the caller must synchronize access to the device before calling SetTime().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Time</em>&nbsp;</td><td>A pointer to the current time. Type <a class="el" href="../../dc/df1/a00662.html">EFI_TIME</a> is defined in the GetTime() function description. Full error checking is performed on the different fields of the <a class="el" href="../../dc/df1/a00662.html">EFI_TIME</a> structure (refer to the <a class="el" href="../../dc/df1/a00662.html">EFI_TIME</a> definition in the GetTime() function description for full details), and EFI_INVALID_PARAMETER is returned if any field is out of range.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EFI_SUCCESS</em>&nbsp;</td><td>The operation completed successfully. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_INVALID_PARAMETER</em>&nbsp;</td><td>A time field is out of range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_DEVICE_ERROR</em>&nbsp;</td><td>The time could not be set due to a hardware error. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ac887fb599a14124c69a644f9319cd72"></a><!-- doxytag: member="UefiRuntimeLib.h::EfiSetVariable" ref="ac887fb599a14124c69a644f9319cd72" args="(IN CHAR16 *VariableName, IN EFI_GUID *VendorGuid, IN UINT32 Attributes, IN UINTN DataSize, IN VOID *Data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> EFIAPI EfiSetVariable           </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="../../d0/d90/a01059.html#8a79e1974f247348d08f0ad87ccfe7a4">CHAR16</a> *&nbsp;</td>
          <td class="paramname"> <em>VariableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="../../d1/d87/a00689.html">EFI_GUID</a> *&nbsp;</td>
          <td class="paramname"> <em>VendorGuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="../../d0/d90/a01059.html#dfe04a44baaebba6143c3a23507ff85b">UINT32</a>&nbsp;</td>
          <td class="paramname"> <em>Attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a>&nbsp;</td>
          <td class="paramname"> <em>DataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN VOID *&nbsp;</td>
          <td class="paramname"> <em>Data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This service is a wrapper for the UEFI Runtime Service GetNextVariableName()<p>
Variables are stored by the firmware and may maintain their values across power cycles. Each vendor may create and manage its own variables without the risk of name conflicts by using a unique VendorGuid.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>VariableName</em>&nbsp;</td><td>the name of the vendor's variable, as a Null-Terminated Unicode String </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VendorGuid</em>&nbsp;</td><td>Unify identifier for vendor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Attributes</em>&nbsp;</td><td>Point to memory location to return the attributes of variable. If the point is NULL, the parameter would be ignored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DataSize</em>&nbsp;</td><td>The size in bytes of Data-Buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>Point to the content of the variable.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EFI_SUCCESS</em>&nbsp;</td><td>The firmware has successfully stored the variable and its data as defined by the Attributes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_INVALID_PARAMETER</em>&nbsp;</td><td>An invalid combination of attribute bits was supplied, or the DataSize exceeds the maximum allowed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_INVALID_PARAMETER</em>&nbsp;</td><td>VariableName is an empty Unicode string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_OUT_OF_RESOURCES</em>&nbsp;</td><td>Not enough storage is available to hold the variable and its data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_DEVICE_ERROR</em>&nbsp;</td><td>The variable could not be saved due to a hardware failure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_WRITE_PROTECTED</em>&nbsp;</td><td>The variable in question is read-only. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_WRITE_PROTECTED</em>&nbsp;</td><td>The variable in question cannot be deleted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_SECURITY_VIOLATION</em>&nbsp;</td><td>The variable could not be written due to EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS set but the AuthInfo does NOT pass the validation check carried out by the firmware. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_NOT_FOUND</em>&nbsp;</td><td>The variable trying to be updated or deleted was not found. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a8c1a0abf86088c2f3346391ad2e1ed7"></a><!-- doxytag: member="UefiRuntimeLib.h::EfiSetVirtualAddressMap" ref="a8c1a0abf86088c2f3346391ad2e1ed7" args="(IN UINTN MemoryMapSize, IN UINTN DescriptorSize, IN UINT32 DescriptorVersion, IN CONST EFI_MEMORY_DESCRIPTOR *VirtualMap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> EFIAPI EfiSetVirtualAddressMap           </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a>&nbsp;</td>
          <td class="paramname"> <em>MemoryMapSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a>&nbsp;</td>
          <td class="paramname"> <em>DescriptorSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="../../d0/d90/a01059.html#dfe04a44baaebba6143c3a23507ff85b">UINT32</a>&nbsp;</td>
          <td class="paramname"> <em>DescriptorVersion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN CONST <a class="el" href="../../dc/df9/a00554.html">EFI_MEMORY_DESCRIPTOR</a> *&nbsp;</td>
          <td class="paramname"> <em>VirtualMap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This service is a wrapper for the UEFI Runtime Service SetVirtualAddressMap().<p>
The SetVirtualAddressMap() function is used by the OS loader. The function can only be called at runtime, and is called by the owner of the system's memory map. I.e., the component which called ExitBootServices(). All events of type EVT_SIGNAL_VIRTUAL_ADDRESS_CHANGE must be signaled before SetVirtualAddressMap() returns.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>MemoryMapSize</em>&nbsp;</td><td>The size in bytes of VirtualMap. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DescriptorSize</em>&nbsp;</td><td>The size in bytes of an entry in the VirtualMap. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DescriptorVersion</em>&nbsp;</td><td>The version of the structure entries in VirtualMap. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VirtualMap</em>&nbsp;</td><td>An array of memory descriptors which contain new virtual address mapping information for all runtime ranges. Type <a class="el" href="../../dc/df9/a00554.html">EFI_MEMORY_DESCRIPTOR</a> is defined in the GetMemoryMap() function description.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EFI_SUCCESS</em>&nbsp;</td><td>The virtual address map has been applied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_UNSUPPORTED</em>&nbsp;</td><td>EFI firmware is not at runtime, or the EFI firmware is already in virtual address mapped mode. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_INVALID_PARAMETER</em>&nbsp;</td><td>DescriptorSize or DescriptorVersion is invalid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_NO_MAPPING</em>&nbsp;</td><td>A virtual address was not supplied for a range in the memory map that requires a mapping. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_NOT_FOUND</em>&nbsp;</td><td>A virtual address was supplied for an address that is not found in the memory map. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="79f24bcdeb622929236aff2d3b986965"></a><!-- doxytag: member="UefiRuntimeLib.h::EfiSetWakeupTime" ref="79f24bcdeb622929236aff2d3b986965" args="(IN BOOLEAN Enable, IN EFI_TIME *Time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> EFIAPI EfiSetWakeupTime           </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="../../d0/d90/a01059.html#000dc5dbcb0d4ba7b6f12c577bc56fba">BOOLEAN</a>&nbsp;</td>
          <td class="paramname"> <em>Enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="../../dc/df1/a00662.html">EFI_TIME</a> *&nbsp;</td>
          <td class="paramname"> <em>Time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This service is a wrapper for the UEFI Runtime Service SetWakeupTime()<p>
Setting a system wakeup alarm causes the system to wake up or power on at the set time. When the alarm fires, the alarm signal is latched until it is acknowledged by calling SetWakeupTime() to disable the alarm. If the alarm fires before the system is put into a sleeping or off state, since the alarm signal is latched the system will immediately wake up. If the alarm fires while the system is off and there is insufficient power to power on the system, the system is powered on when power is restored.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Enable</em>&nbsp;</td><td>Enable or disable the wakeup alarm. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Time</em>&nbsp;</td><td>If Enable is TRUE, the time to set the wakeup alarm for. Type <a class="el" href="../../dc/df1/a00662.html">EFI_TIME</a> is defined in the GetTime() function description. If Enable is FALSE, then this parameter is optional, and may be NULL.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EFI_SUCCESS</em>&nbsp;</td><td>If Enable is TRUE, then the wakeup alarm was enabled. If Enable is FALSE, then the wakeup alarm was disabled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_INVALID_PARAMETER</em>&nbsp;</td><td>A time field is out of range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_DEVICE_ERROR</em>&nbsp;</td><td>The wakeup time could not be set due to a hardware error. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_UNSUPPORTED</em>&nbsp;</td><td>A wakeup timer is not supported on this platform. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3ab21568c6aae668cb3e75770f6ccb47"></a><!-- doxytag: member="UefiRuntimeLib.h::EfiUpdateCapsule" ref="3ab21568c6aae668cb3e75770f6ccb47" args="(IN EFI_CAPSULE_HEADER **CapsuleHeaderArray, IN UINTN CapsuleCount, IN EFI_PHYSICAL_ADDRESS ScatterGatherList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> EFIAPI EfiUpdateCapsule           </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="../../d8/d91/a00410.html">EFI_CAPSULE_HEADER</a> **&nbsp;</td>
          <td class="paramname"> <em>CapsuleHeaderArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a>&nbsp;</td>
          <td class="paramname"> <em>CapsuleCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="../../dd/d95/a01247.html#31bc7e7faeab8d2940ee34f21d41cd04">EFI_PHYSICAL_ADDRESS</a>&nbsp;</td>
          <td class="paramname"> <em>ScatterGatherList</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This service is a wrapper for the UEFI Runtime Service UpdateCapsule().<p>
Passes capsules to the firmware with both virtual and physical mapping. Depending on the intended consumption, the firmware may process the capsule immediately. If the payload should persist across a system reset, the reset value returned from EFI_QueryCapsuleCapabilities must be passed into ResetSystem() and will cause the capsule to be processed by the firmware as part of the reset process.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CapsuleHeaderArray</em>&nbsp;</td><td>Virtual pointer to an array of virtual pointers to the capsules being passed into update capsule. Each capsules is assumed to stored in contiguous virtual memory. The capsules in the CapsuleHeaderArray must be the same capsules as the ScatterGatherList. The CapsuleHeaderArray must have the capsules in the same order as the ScatterGatherList. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CapsuleCount</em>&nbsp;</td><td>Number of pointers to <a class="el" href="../../d8/d91/a00410.html">EFI_CAPSULE_HEADER</a> in CaspuleHeaderArray. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ScatterGatherList</em>&nbsp;</td><td>Physical pointer to a set of <a class="el" href="../../de/d3d/a00409.html">EFI_CAPSULE_BLOCK_DESCRIPTOR</a> that describes the location in physical memory of a set of capsules. See Related Definitions for an explanation of how more than one capsule is passed via this interface. The capsules in the ScatterGatherList must be in the same order as the CapsuleHeaderArray. This parameter is only referenced if the capsules are defined to persist across system reset.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EFI_SUCCESS</em>&nbsp;</td><td>Valid capsule was passed. If CAPSULE_FLAGS_PERSIT_ACROSS_RESET is not set, the capsule has been successfully processed by the firmware. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_INVALID_PARAMETER</em>&nbsp;</td><td>CapsuleSize or HeaderSize is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_INVALID_PARAMETER</em>&nbsp;</td><td>CapsuleCount is 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_DEVICE_ERROR</em>&nbsp;</td><td>The capsule update was started, but failed due to a device error. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_UNSUPPORTED</em>&nbsp;</td><td>The capsule type is not supported on this platform. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_OUT_OF_RESOURCES</em>&nbsp;</td><td>There were insufficient resources to process the capsule. </td></tr>
  </table>
</dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Aug 7 13:53:24 2009 for MdePkg[ALL] by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>
