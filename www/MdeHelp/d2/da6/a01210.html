<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>MdePkg[ALL]: MdePkg/Include/Protocol/PciPlatform.h File Reference</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
<link href="../../tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="../../main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="../../annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="../../files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="../../globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>MdePkg/Include/Protocol/PciPlatform.h File Reference</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/ddf/a00224.html">_EFI_PCI_PLATFORM_PROTOCOL</a></td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/da6/a01210.html#021ef8807f06f97fd0856a164bb4dd37">EFI_PCI_PLATFORM_PROTOCOL_GUID</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/da6/a01210.html#320a3815d95128330a34571ddbf5043f">EFI_RESERVE_NONE_IO_ALIAS</a>&nbsp;&nbsp;&nbsp;0x0000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/da6/a01210.html#e6568d7ab32f5197d3047ec197778bcc">EFI_RESERVE_ISA_IO_ALIAS</a>&nbsp;&nbsp;&nbsp;0x0001</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/da6/a01210.html#c00337da342d6e0f6b1ed07e7ce7512b">EFI_RESERVE_ISA_IO_NO_ALIAS</a>&nbsp;&nbsp;&nbsp;0x0002</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/da6/a01210.html#f48d6ca9ee365bfaf1f04dec3b70df22">EFI_RESERVE_VGA_IO_ALIAS</a>&nbsp;&nbsp;&nbsp;0x0004</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/da6/a01210.html#244b893ac496a00d06e0a92ef2950b5c">EFI_RESERVE_VGA_IO_NO_ALIAS</a>&nbsp;&nbsp;&nbsp;0x0008</td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef struct <br class="typebreak">
<a class="el" href="../../d5/ddf/a00224.html">_EFI_PCI_PLATFORM_PROTOCOL</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/da6/a01210.html#60010c5afb5884d484780f4f4ef6a1f7">EFI_PCI_PLATFORM_PROTOCOL</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="../../d0/d90/a01059.html#dfe04a44baaebba6143c3a23507ff85b">UINT32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/da6/a01210.html#2821b7224f8d479b96195b13c484f818">EFI_PCI_PLATFORM_POLICY</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="../../d2/da6/a01210.html#f777a84ba5ba02bacf0d521c305806c1">EFI_PCI_EXECUTION_PHASE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/da6/a01210.html#927d10c011a76195835dcef4fbd70867">EFI_PCI_CHIPSET_EXECUTION_PHASE</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(EFIAPI *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/da6/a01210.html#6cbd251f4c1f83ac82f887b1835051c3">EFI_PCI_PLATFORM_PHASE_NOTIFY</a> )(IN <a class="el" href="../../d5/ddf/a00224.html">EFI_PCI_PLATFORM_PROTOCOL</a> *This, IN <a class="el" href="../../dd/d95/a01247.html#f943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> HostBridge, IN <a class="el" href="../../dc/d9e/a01206.html#c2617ff12da15c215d03a6bfe95fc789">EFI_PCI_HOST_BRIDGE_RESOURCE_ALLOCATION_PHASE</a> Phase, IN <a class="el" href="../../d2/da6/a01210.html#f777a84ba5ba02bacf0d521c305806c1">EFI_PCI_CHIPSET_EXECUTION_PHASE</a> ChipsetPhase)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(EFIAPI *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/da6/a01210.html#4228c8e128afa206fff3a278d36b0e36">EFI_PCI_PLATFORM_PREPROCESS_CONTROLLER</a> )(IN <a class="el" href="../../d5/ddf/a00224.html">EFI_PCI_PLATFORM_PROTOCOL</a> *This, IN <a class="el" href="../../dd/d95/a01247.html#f943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> HostBridge, IN <a class="el" href="../../dd/d95/a01247.html#f943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> RootBridge, IN <a class="el" href="../../d7/db1/a00590.html">EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_PCI_ADDRESS</a> PciAddress, IN <a class="el" href="../../dc/d9e/a01206.html#ec6d89c8d097658159417eefc8131cdd">EFI_PCI_CONTROLLER_RESOURCE_ALLOCATION_PHASE</a> Phase, IN <a class="el" href="../../d2/da6/a01210.html#f777a84ba5ba02bacf0d521c305806c1">EFI_PCI_CHIPSET_EXECUTION_PHASE</a> ChipsetPhase)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(EFIAPI *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/da6/a01210.html#43800b32781fd62e6b0244187aa3ff64">EFI_PCI_PLATFORM_GET_PLATFORM_POLICY</a> )(IN <a class="el" href="../../d5/ddf/a00224.html">EFI_PCI_PLATFORM_PROTOCOL</a> *This, OUT <a class="el" href="../../d2/da6/a01210.html#2821b7224f8d479b96195b13c484f818">EFI_PCI_PLATFORM_POLICY</a> *PciPolicy)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(EFIAPI *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/da6/a01210.html#990a66ad36639c81b5b87808a8206bb8">EFI_PCI_PLATFORM_GET_PCI_ROM</a> )(IN <a class="el" href="../../d5/ddf/a00224.html">EFI_PCI_PLATFORM_PROTOCOL</a> *This, IN <a class="el" href="../../dd/d95/a01247.html#f943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> PciHandle, OUT VOID **RomImage, OUT <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> *RomSize)</td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/da6/a01210.html#f777a84ba5ba02bacf0d521c305806c1">EFI_PCI_EXECUTION_PHASE</a> { <br>
&nbsp;&nbsp;<a class="el" href="../../d2/da6/a01210.html#f777a84ba5ba02bacf0d521c305806c1fab5d18bf35ec5c9a4711326c20b5a11">BeforePciHostBridge</a> =  0, 
<a class="el" href="../../d2/da6/a01210.html#f777a84ba5ba02bacf0d521c305806c19af7e1569186eeea572243fb8db20eef">ChipsetEntry</a> =  0, 
<a class="el" href="../../d2/da6/a01210.html#f777a84ba5ba02bacf0d521c305806c18d866bb50e0437dd19450111dc85479c">AfterPciHostBridge</a> =  1, 
<a class="el" href="../../d2/da6/a01210.html#f777a84ba5ba02bacf0d521c305806c14c492e6b581868dc750342d06f66a805">ChipsetExit</a> =  1, 
<br>
&nbsp;&nbsp;<a class="el" href="../../d2/da6/a01210.html#f777a84ba5ba02bacf0d521c305806c11aaecc156e2d814c5c78bfa236fb096d">MaximumChipsetPhase</a>
<br>
 }</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="../../d1/d87/a00689.html">EFI_GUID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/da6/a01210.html#ef3f75513b3daf5554a87fb8294b24fa">gEfiPciPlatformProtocolGuid</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This file declares PlatfromOpRom protocols which provides the interface between the PCI bus driver/PCI Host Bridge Resource Allocation driver and a platform-specific driver to describe the unique features of a platform. This protocol is optional.<p>
Copyright (c) 2007 - 2009, Intel Corporation All rights reserved. This program and the accompanying materials are licensed and made available under the terms and conditions of the BSD License which accompanies this distribution. The full text of the license may be found at <a href="http://opensource.org/licenses/bsd-license.php">http://opensource.org/licenses/bsd-license.php</a><p>
THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.<p>
<dl class="user" compact><dt><b>Revision Reference:</b></dt><dd>This Protocol is defined in UEFI Platform Initialization Specification 1.2 Volume 5: Standards </dd></dl>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="021ef8807f06f97fd0856a164bb4dd37"></a><!-- doxytag: member="PciPlatform.h::EFI_PCI_PLATFORM_PROTOCOL_GUID" ref="021ef8807f06f97fd0856a164bb4dd37" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_PCI_PLATFORM_PROTOCOL_GUID          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
    0x7d75280, 0x27d4, 0x4d69, {0x90, 0xd0, 0x56, 0x43, 0xe2, 0x38, 0xb3, 0x41} \
  }
</pre></div>This file must be included because the EFI_PCI_PLATFORM_PROTOCOL uses EFI_PCI_HOST_BRIDGE_RESOURCE_ALLOCATION_PHASE Global ID for the EFI_PCI_PLATFORM_PROTOCOL 
</div>
</div><p>
<a class="anchor" name="e6568d7ab32f5197d3047ec197778bcc"></a><!-- doxytag: member="PciPlatform.h::EFI_RESERVE_ISA_IO_ALIAS" ref="e6568d7ab32f5197d3047ec197778bcc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_RESERVE_ISA_IO_ALIAS&nbsp;&nbsp;&nbsp;0x0001          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets aside ISA I/O range and all aliases<ul>
<li>n100..n3FF</li><li>n500..n7FF</li><li>n900..nBFF</li><li>nD00..nFFF </li></ul>

</div>
</div><p>
<a class="anchor" name="c00337da342d6e0f6b1ed07e7ce7512b"></a><!-- doxytag: member="PciPlatform.h::EFI_RESERVE_ISA_IO_NO_ALIAS" ref="c00337da342d6e0f6b1ed07e7ce7512b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_RESERVE_ISA_IO_NO_ALIAS&nbsp;&nbsp;&nbsp;0x0002          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets aside ISA I/O range 0x100-0x3FF 
</div>
</div><p>
<a class="anchor" name="320a3815d95128330a34571ddbf5043f"></a><!-- doxytag: member="PciPlatform.h::EFI_RESERVE_NONE_IO_ALIAS" ref="320a3815d95128330a34571ddbf5043f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_RESERVE_NONE_IO_ALIAS&nbsp;&nbsp;&nbsp;0x0000          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Does not set aside either ISA or VGA I/O resources during PCI enumeration. 
</div>
</div><p>
<a class="anchor" name="f48d6ca9ee365bfaf1f04dec3b70df22"></a><!-- doxytag: member="PciPlatform.h::EFI_RESERVE_VGA_IO_ALIAS" ref="f48d6ca9ee365bfaf1f04dec3b70df22" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_RESERVE_VGA_IO_ALIAS&nbsp;&nbsp;&nbsp;0x0004          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets aside VGA I/O ranges and all aliases 
</div>
</div><p>
<a class="anchor" name="244b893ac496a00d06e0a92ef2950b5c"></a><!-- doxytag: member="PciPlatform.h::EFI_RESERVE_VGA_IO_NO_ALIAS" ref="244b893ac496a00d06e0a92ef2950b5c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_RESERVE_VGA_IO_NO_ALIAS&nbsp;&nbsp;&nbsp;0x0008          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets aside VGA I/O rangess 
</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="927d10c011a76195835dcef4fbd70867"></a><!-- doxytag: member="PciPlatform.h::EFI_PCI_CHIPSET_EXECUTION_PHASE" ref="927d10c011a76195835dcef4fbd70867" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../d2/da6/a01210.html#f777a84ba5ba02bacf0d521c305806c1">EFI_PCI_EXECUTION_PHASE</a> <a class="el" href="../../d2/da6/a01210.html#f777a84ba5ba02bacf0d521c305806c1">EFI_PCI_CHIPSET_EXECUTION_PHASE</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="990a66ad36639c81b5b87808a8206bb8"></a><!-- doxytag: member="PciPlatform.h::EFI_PCI_PLATFORM_GET_PCI_ROM" ref="990a66ad36639c81b5b87808a8206bb8" args=")(IN EFI_PCI_PLATFORM_PROTOCOL *This, IN EFI_HANDLE PciHandle, OUT VOID **RomImage, OUT UINTN *RomSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(EFIAPI * <a class="el" href="../../d2/da6/a01210.html#990a66ad36639c81b5b87808a8206bb8">EFI_PCI_PLATFORM_GET_PCI_ROM</a>)(IN <a class="el" href="../../d5/ddf/a00224.html">EFI_PCI_PLATFORM_PROTOCOL</a> *This, IN <a class="el" href="../../dd/d95/a01247.html#f943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> PciHandle, OUT VOID **RomImage, OUT <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> *RomSize)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the PCI device's option ROM from a platform-specific location.<p>
The GetPciRom() function gets the PCI device's option ROM from a platform-specific location. The option ROM will be loaded into memory. This member function is used to return an image that is packaged as a PCI 2.2 option ROM. The image may contain both legacy and EFI option ROMs. See the UEFI 2.0 Specification for details. This member function can be used to return option ROM images for embedded controllers. Option ROMs for embedded controllers are typically stored in platform-specific storage, and this member function can retrieve it from that storage and return it to the PCI bus driver. The PCI bus driver will call this member function before scanning the ROM that is attached to any controller, which allows a platform to specify a ROM image that is different from the ROM image on a PCI card.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>This</em>&nbsp;</td><td>Pointer to the EFI_PCI_PLATFORM_PROTOCOL instance. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>PciHandle</em>&nbsp;</td><td>The handle of the PCI device. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>RomImage</em>&nbsp;</td><td>If the call succeeds, the pointer to the pointer to the option ROM image. Otherwise, this field is undefined. The memory for RomImage is allocated by <a class="el" href="../../d5/ddf/a00224.html#e9c6834f40f6791bc3d24b2109441327">EFI_PCI_PLATFORM_PROTOCOL.GetPciRom()</a> using the EFI Boot Service <a class="el" href="../../d6/d6a/a01072.html#646c0f82c2a35557dda175dbfcd26e96">AllocatePool()</a>. It is the caller's responsibility to free the memory using the EFI Boot Service <a class="el" href="../../d6/d6a/a01072.html#8b1cbc21e0cebcfc6a992546ec9b4941">FreePool()</a>, when the caller is done with the option ROM. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>RomSize</em>&nbsp;</td><td>If the call succeeds, a pointer to the size of the option ROM size. Otherwise, this field is undefined.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EFI_SUCCESS</em>&nbsp;</td><td>The option ROM was available for this device and loaded into memory. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_NOT_FOUND</em>&nbsp;</td><td>No option ROM was available for this device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_OUT_OF_RESOURCES</em>&nbsp;</td><td>No memory was available to load the option ROM. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_DEVICE_ERROR</em>&nbsp;</td><td>An error occurred in getting the option ROM. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="43800b32781fd62e6b0244187aa3ff64"></a><!-- doxytag: member="PciPlatform.h::EFI_PCI_PLATFORM_GET_PLATFORM_POLICY" ref="43800b32781fd62e6b0244187aa3ff64" args=")(IN EFI_PCI_PLATFORM_PROTOCOL *This, OUT EFI_PCI_PLATFORM_POLICY *PciPolicy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(EFIAPI * <a class="el" href="../../d2/da6/a01210.html#43800b32781fd62e6b0244187aa3ff64">EFI_PCI_PLATFORM_GET_PLATFORM_POLICY</a>)(IN <a class="el" href="../../d5/ddf/a00224.html">EFI_PCI_PLATFORM_PROTOCOL</a> *This, OUT <a class="el" href="../../d2/da6/a01210.html#2821b7224f8d479b96195b13c484f818">EFI_PCI_PLATFORM_POLICY</a> *PciPolicy)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the platform policy regarding enumeration.<p>
The GetPlatformPolicy() function retrieves the platform policy regarding PCI enumeration. The PCI bus driver and the PCI Host Bridge Resource Allocation Protocol driver can call this member function to retrieve the policy.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>This</em>&nbsp;</td><td>Pointer to the EFI_PCI_PLATFORM_PROTOCOL instance. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>PciPolicy</em>&nbsp;</td><td>The platform policy with respect to VGA and ISA aliasing.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EFI_SUCCESS</em>&nbsp;</td><td>The function completed successfully. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_INVALID_PARAMETER</em>&nbsp;</td><td>PciPolicy is NULL. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6cbd251f4c1f83ac82f887b1835051c3"></a><!-- doxytag: member="PciPlatform.h::EFI_PCI_PLATFORM_PHASE_NOTIFY" ref="6cbd251f4c1f83ac82f887b1835051c3" args=")(IN EFI_PCI_PLATFORM_PROTOCOL *This, IN EFI_HANDLE HostBridge, IN EFI_PCI_HOST_BRIDGE_RESOURCE_ALLOCATION_PHASE Phase, IN EFI_PCI_CHIPSET_EXECUTION_PHASE ChipsetPhase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(EFIAPI * <a class="el" href="../../d2/da6/a01210.html#6cbd251f4c1f83ac82f887b1835051c3">EFI_PCI_PLATFORM_PHASE_NOTIFY</a>)(IN <a class="el" href="../../d5/ddf/a00224.html">EFI_PCI_PLATFORM_PROTOCOL</a> *This, IN <a class="el" href="../../dd/d95/a01247.html#f943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> HostBridge, IN <a class="el" href="../../dc/d9e/a01206.html#c2617ff12da15c215d03a6bfe95fc789">EFI_PCI_HOST_BRIDGE_RESOURCE_ALLOCATION_PHASE</a> Phase, IN <a class="el" href="../../d2/da6/a01210.html#f777a84ba5ba02bacf0d521c305806c1">EFI_PCI_CHIPSET_EXECUTION_PHASE</a> ChipsetPhase)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The notification from the PCI bus enumerator to the platform that it is about to enter a certain phase during the enumeration process.<p>
The PlatformNotify() function can be used to notify the platform driver so that it can perform platform-specific actions. No specific actions are required. Eight notification points are defined at this time. More synchronization points may be added as required in the future. The PCI bus driver calls the platform driver twice for every Phase-once before the PCI Host Bridge Resource Allocation Protocol driver is notified, and once after the PCI Host Bridge Resource Allocation Protocol driver has been notified. This member function may not perform any error checking on the input parameters. It also does not return any error codes. If this member function detects any error condition, it needs to handle those errors on its own because there is no way to surface any errors to the caller.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>This</em>&nbsp;</td><td>Pointer to the EFI_PCI_PLATFORM_PROTOCOL instance. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>HostBridge</em>&nbsp;</td><td>The handle of the host bridge controller. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Phase</em>&nbsp;</td><td>The phase of the PCI bus enumeration. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ChipsetPhase</em>&nbsp;</td><td>Defines the execution phase of the PCI chipset driver.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EFI_SUCCESS</em>&nbsp;</td><td>The function completed successfully. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2821b7224f8d479b96195b13c484f818"></a><!-- doxytag: member="PciPlatform.h::EFI_PCI_PLATFORM_POLICY" ref="2821b7224f8d479b96195b13c484f818" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../d0/d90/a01059.html#dfe04a44baaebba6143c3a23507ff85b">UINT32</a> <a class="el" href="../../d2/da6/a01210.html#2821b7224f8d479b96195b13c484f818">EFI_PCI_PLATFORM_POLICY</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
EFI_PCI_PLATYFORM_POLICY that is a bitmask with the following legal combinations:<ul>
<li>EFI_RESERVE_NONE_IO_ALIAS:<br>
 Does not set aside either ISA or VGA I/O resources during PCI enumeration. By using this selection, the platform indicates that it does not want to support a PCI device that requires ISA or legacy VGA resources. If a PCI device driver asks for these resources, the request will be turned down.</li><li>EFI_RESERVE_ISA_IO_ALIAS | EFI_RESERVE_VGA_IO_ALIAS:<br>
 Sets aside the ISA I/O range and all the aliases during PCI enumeration. VGA I/O ranges and aliases are included in ISA alias ranges. In this scheme, 75 percent of the I/O space remains unused. By using this selection, the platform indicates that it wants to support PCI devices that require the following, at the cost of wasted I/O space: ISA range and its aliases Legacy VGA range and its aliases The PCI bus driver will not allocate I/O addresses out of the ISA I/O range and its aliases. The following are the ISA I/O ranges:<ul>
<li>n100..n3FF</li><li>n500..n7FF</li><li>n900..nBFF</li><li>nD00..nFFF</li></ul>
</li></ul>
<p>
In this case, the PCI bus driver will ask the PCI host bridge driver for larger I/O ranges. The PCI host bridge driver is not aware of the ISA aliasing policy and merely attempts to allocate the requested ranges. The first device that requests the legacy VGA range will get all the legacy VGA range plus its aliased addresses forwarded to it. The first device that requests the legacy ISA range will get all the legacy ISA range plus its aliased addresses forwarded to it.<ul>
<li>EFI_RESERVE_ISA_IO_NO_ALIAS | EFI_RESERVE_VGA_IO_ALIAS:<br>
 Sets aside the ISA I/O range (0x100 - 0x3FF) during PCI enumeration and the aliases of the VGA I/O ranges. By using this selection, the platform indicates that it will support VGA devices that require VGA ranges, including those that require VGA aliases. The platform further wants to support non-VGA devices that ask for the ISA range (0x100 - 3FF), but not if it also asks for the ISA aliases. The PCI bus driver will not allocate I/O addresses out of the legacy ISA I/O range (0x100 - 0x3FF) range or the aliases of the VGA I/O range. If a PCI device driver asks for the ISA I/O ranges, including aliases, the request will be turned down. The first device that requests the legacy VGA range will get all the legacy VGA range plus its aliased addresses forwarded to it. When the legacy VGA device asks for legacy VGA ranges and its aliases, all the upstream PCI-to-PCI bridges must be set up to perform 10-bit decode on legacy VGA ranges. To prevent two bridges from positively decoding the same address, all PCI-to-PCI bridges that are peers to this bridge will have to be set up to not decode ISA aliased ranges. In that case, all the devices behind the peer bridges can occupy only I/O addresses that are not ISA aliases. This is a limitation of PCI-to-PCI bridges and is described in the white paper PCI-to-PCI Bridges and Card Bus Controllers on Windows 2000, Windows XP, and Windows Server 2003. The PCI enumeration process must be cognizant of this restriction.</li><li>EFI_RESERVE_ISA_IO_NO_ALIAS | EFI_RESERVE_VGA_IO_NO_ALIAS:<br>
 Sets aside the ISA I/O range (0x100 - 0x3FF) during PCI enumeration. VGA I/O ranges are included in the ISA range. By using this selection, the platform indicates that it wants to support PCI devices that require the ISA range and legacy VGA range, but it does not want to support devices that require ISA alias ranges or VGA alias ranges. The PCI bus driver will not allocate I/O addresses out of the legacy ISA I/O range (0x100-0x3FF). If a PCI device driver asks for the ISA I/O ranges, including aliases, the request will be turned down. By using this selection, the platform indicates that it will support VGA devices that require VGA ranges, but it will not support VGA devices that require VGA aliases. To truly support 16-bit VGA decode, all the PCIto- PCI bridges that are upstream to a VGA device, as well as upstream to the parent PCI root bridge, must support 16-bit VGA I/O decode. See the PCI-to-PCI Bridge Architecture Specification for information regarding the 16-bit VGA decode support. This requirement must hold true for every VGA device in the system. If any of these bridges does not support 16-bit VGA decode, it will positively decode all the aliases of the VGA I/O ranges and this selection must be treated like EFI_RESERVE_ISA_IO_NO_ALIAS | EFI_RESERVE_VGA_IO_ALIAS. </li></ul>

</div>
</div><p>
<a class="anchor" name="4228c8e128afa206fff3a278d36b0e36"></a><!-- doxytag: member="PciPlatform.h::EFI_PCI_PLATFORM_PREPROCESS_CONTROLLER" ref="4228c8e128afa206fff3a278d36b0e36" args=")(IN EFI_PCI_PLATFORM_PROTOCOL *This, IN EFI_HANDLE HostBridge, IN EFI_HANDLE RootBridge, IN EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_PCI_ADDRESS PciAddress, IN EFI_PCI_CONTROLLER_RESOURCE_ALLOCATION_PHASE Phase, IN EFI_PCI_CHIPSET_EXECUTION_PHASE ChipsetPhase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(EFIAPI * <a class="el" href="../../d2/da6/a01210.html#4228c8e128afa206fff3a278d36b0e36">EFI_PCI_PLATFORM_PREPROCESS_CONTROLLER</a>)(IN <a class="el" href="../../d5/ddf/a00224.html">EFI_PCI_PLATFORM_PROTOCOL</a> *This, IN <a class="el" href="../../dd/d95/a01247.html#f943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> HostBridge, IN <a class="el" href="../../dd/d95/a01247.html#f943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> RootBridge, IN <a class="el" href="../../d7/db1/a00590.html">EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_PCI_ADDRESS</a> PciAddress, IN <a class="el" href="../../dc/d9e/a01206.html#ec6d89c8d097658159417eefc8131cdd">EFI_PCI_CONTROLLER_RESOURCE_ALLOCATION_PHASE</a> Phase, IN <a class="el" href="../../d2/da6/a01210.html#f777a84ba5ba02bacf0d521c305806c1">EFI_PCI_CHIPSET_EXECUTION_PHASE</a> ChipsetPhase)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The notification from the PCI bus enumerator to the platform for each PCI controller at several predefined points during PCI controller initialization.<p>
The PlatformPrepController() function can be used to notify the platform driver so that it can perform platform-specific actions. No specific actions are required. Several notification points are defined at this time. More synchronization points may be added as required in the future. The PCI bus driver calls the platform driver twice for every PCI controller-once before the PCI Host Bridge Resource Allocation Protocol driver is notified, and once after the PCI Host Bridge Resource Allocation Protocol driver has been notified. This member function may not perform any error checking on the input parameters. It also does not return any error codes. If this member function detects any error condition, it needs to handle those errors on its own because there is no way to surface any errors to the caller.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>This</em>&nbsp;</td><td>Pointer to the EFI_PCI_PLATFORM_PROTOCOL instance. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>HostBridge</em>&nbsp;</td><td>The associated PCI host bridge handle. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>RootBridge</em>&nbsp;</td><td>The associated PCI root bridge handle. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>PciAddress</em>&nbsp;</td><td>The address of the PCI device on the PCI bus. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Phase</em>&nbsp;</td><td>The phase of the PCI controller enumeration. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ChipsetPhase</em>&nbsp;</td><td>Defines the execution phase of the PCI chipset driver.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EFI_SUCCESS</em>&nbsp;</td><td>The function completed successfully. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="60010c5afb5884d484780f4f4ef6a1f7"></a><!-- doxytag: member="PciPlatform.h::EFI_PCI_PLATFORM_PROTOCOL" ref="60010c5afb5884d484780f4f4ef6a1f7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="../../d5/ddf/a00224.html">_EFI_PCI_PLATFORM_PROTOCOL</a> <a class="el" href="../../d5/ddf/a00224.html">EFI_PCI_PLATFORM_PROTOCOL</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Forward declaration for EFI_PCI_PLATFORM_PROTOCOL 
</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="f777a84ba5ba02bacf0d521c305806c1"></a><!-- doxytag: member="PciPlatform.h::EFI_PCI_EXECUTION_PHASE" ref="f777a84ba5ba02bacf0d521c305806c1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d2/da6/a01210.html#f777a84ba5ba02bacf0d521c305806c1">EFI_PCI_EXECUTION_PHASE</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
EFI_PCI_EXECUTION_PHASE is used to call a platform protocol and execute platform-specific code. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="f777a84ba5ba02bacf0d521c305806c1fab5d18bf35ec5c9a4711326c20b5a11"></a><!-- doxytag: member="BeforePciHostBridge" ref="f777a84ba5ba02bacf0d521c305806c1fab5d18bf35ec5c9a4711326c20b5a11" args="" -->BeforePciHostBridge</em>&nbsp;</td><td>
The phase that indicates the entry point to the PCI Bus Notify phase. This platform hook is called before the PCI bus driver calls the EFI_PCI_HOST_BRIDGE_RESOURCE_ALLOCATION_PROTOCOL driver. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="f777a84ba5ba02bacf0d521c305806c19af7e1569186eeea572243fb8db20eef"></a><!-- doxytag: member="ChipsetEntry" ref="f777a84ba5ba02bacf0d521c305806c19af7e1569186eeea572243fb8db20eef" args="" -->ChipsetEntry</em>&nbsp;</td><td>
The phase that indicates the entry point to the PCI Bus Notify phase. This platform hook is called before the PCI bus driver calls the EFI_PCI_HOST_BRIDGE_RESOURCE_ALLOCATION_PROTOCOL driver. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="f777a84ba5ba02bacf0d521c305806c18d866bb50e0437dd19450111dc85479c"></a><!-- doxytag: member="AfterPciHostBridge" ref="f777a84ba5ba02bacf0d521c305806c18d866bb50e0437dd19450111dc85479c" args="" -->AfterPciHostBridge</em>&nbsp;</td><td>
The phase that indicates the exit point to the Chipset Notify phase before returning to the PCI Bus Driver Notify phase. This platform hook is called after the PCI bus driver calls the EFI_PCI_HOST_BRIDGE_RESOURCE_ALLOCATION_PROTOCOL driver. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="f777a84ba5ba02bacf0d521c305806c14c492e6b581868dc750342d06f66a805"></a><!-- doxytag: member="ChipsetExit" ref="f777a84ba5ba02bacf0d521c305806c14c492e6b581868dc750342d06f66a805" args="" -->ChipsetExit</em>&nbsp;</td><td>
The phase that indicates the exit point to the Chipset Notify phase before returning to the PCI Bus Driver Notify phase. This platform hook is called after the PCI bus driver calls the EFI_PCI_HOST_BRIDGE_RESOURCE_ALLOCATION_PROTOCOL driver. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="f777a84ba5ba02bacf0d521c305806c11aaecc156e2d814c5c78bfa236fb096d"></a><!-- doxytag: member="MaximumChipsetPhase" ref="f777a84ba5ba02bacf0d521c305806c11aaecc156e2d814c5c78bfa236fb096d" args="" -->MaximumChipsetPhase</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="ef3f75513b3daf5554a87fb8294b24fa"></a><!-- doxytag: member="PciPlatform.h::gEfiPciPlatformProtocolGuid" ref="ef3f75513b3daf5554a87fb8294b24fa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d87/a00689.html">EFI_GUID</a> <a class="el" href="../../d2/da6/a01210.html#ef3f75513b3daf5554a87fb8294b24fa">gEfiPciPlatformProtocolGuid</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Aug 7 13:53:35 2009 for MdePkg[ALL] by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>
