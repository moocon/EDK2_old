<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>MdePkg[ALL]: MdePkg/Include/Protocol/DriverBinding.h File Reference</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
<link href="../../tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="../../main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="../../annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="../../files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="../../globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>MdePkg/Include/Protocol/DriverBinding.h File Reference</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/db2/a00020.html">_EFI_DRIVER_BINDING_PROTOCOL</a></td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dc7/a01170.html#7772d8413bb151a59688a6d679198ac4">EFI_DRIVER_BINDING_PROTOCOL_GUID</a></td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef struct <br class="typebreak">
<a class="el" href="../../db/db2/a00020.html">_EFI_DRIVER_BINDING_PROTOCOL</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dc7/a01170.html#e405748766385623110e2553c5eada18">EFI_DRIVER_BINDING_PROTOCOL</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(EFIAPI *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dc7/a01170.html#69fa28f889a84cd11d031137433c0e8b">EFI_DRIVER_BINDING_SUPPORTED</a> )(IN <a class="el" href="../../db/db2/a00020.html">EFI_DRIVER_BINDING_PROTOCOL</a> *This, IN <a class="el" href="../../dd/d95/a01247.html#f943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ControllerHandle, IN <a class="el" href="../../df/d70/a00431.html">EFI_DEVICE_PATH_PROTOCOL</a> *RemainingDevicePath)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(EFIAPI *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dc7/a01170.html#40b5262ed68f77f5b18cedb926a6646a">EFI_DRIVER_BINDING_START</a> )(IN <a class="el" href="../../db/db2/a00020.html">EFI_DRIVER_BINDING_PROTOCOL</a> *This, IN <a class="el" href="../../dd/d95/a01247.html#f943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ControllerHandle, IN <a class="el" href="../../df/d70/a00431.html">EFI_DEVICE_PATH_PROTOCOL</a> *RemainingDevicePath)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(EFIAPI *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dc7/a01170.html#909abfff42bf5f5342db312542b44be6">EFI_DRIVER_BINDING_STOP</a> )(IN <a class="el" href="../../db/db2/a00020.html">EFI_DRIVER_BINDING_PROTOCOL</a> *This, IN <a class="el" href="../../dd/d95/a01247.html#f943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ControllerHandle, IN <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> NumberOfChildren, IN <a class="el" href="../../dd/d95/a01247.html#f943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> *ChildHandleBuffer)</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="../../d1/d87/a00689.html">EFI_GUID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dc7/a01170.html#28c565ce727b8661523ea1718e32ee8c">gEfiDriverBindingProtocolGuid</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
UEFI DriverBinding Protocol is defined in UEFI specification.<p>
This protocol is produced by every driver that follows the UEFI Driver Model, and it is the central component that allows drivers and controllers to be managed.<p>
Copyright (c) 2006 - 2009, Intel Corporation All rights reserved. This program and the accompanying materials are licensed and made available under the terms and conditions of the BSD License which accompanies this distribution. The full text of the license may be found at <a href="http://opensource.org/licenses/bsd-license.php">http://opensource.org/licenses/bsd-license.php</a><p>
THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED. <hr><h2>Define Documentation</h2>
<a class="anchor" name="7772d8413bb151a59688a6d679198ac4"></a><!-- doxytag: member="DriverBinding.h::EFI_DRIVER_BINDING_PROTOCOL_GUID" ref="7772d8413bb151a59688a6d679198ac4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_DRIVER_BINDING_PROTOCOL_GUID          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
    0x18a031ab, 0xb443, 0x4d1a, {0xa5, 0xc0, 0xc, 0x9, 0x26, 0x1e, 0x9f, 0x71 } \
  }
</pre></div>Global ID for the ControllerHandle Driver Protocol 
</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="e405748766385623110e2553c5eada18"></a><!-- doxytag: member="DriverBinding.h::EFI_DRIVER_BINDING_PROTOCOL" ref="e405748766385623110e2553c5eada18" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="../../db/db2/a00020.html">_EFI_DRIVER_BINDING_PROTOCOL</a> <a class="el" href="../../db/db2/a00020.html">EFI_DRIVER_BINDING_PROTOCOL</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="40b5262ed68f77f5b18cedb926a6646a"></a><!-- doxytag: member="DriverBinding.h::EFI_DRIVER_BINDING_START" ref="40b5262ed68f77f5b18cedb926a6646a" args=")(IN EFI_DRIVER_BINDING_PROTOCOL *This, IN EFI_HANDLE ControllerHandle, IN EFI_DEVICE_PATH_PROTOCOL *RemainingDevicePath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(EFIAPI * <a class="el" href="../../d3/dc7/a01170.html#40b5262ed68f77f5b18cedb926a6646a">EFI_DRIVER_BINDING_START</a>)(IN <a class="el" href="../../db/db2/a00020.html">EFI_DRIVER_BINDING_PROTOCOL</a> *This, IN <a class="el" href="../../dd/d95/a01247.html#f943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ControllerHandle, IN <a class="el" href="../../df/d70/a00431.html">EFI_DEVICE_PATH_PROTOCOL</a> *RemainingDevicePath)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start this driver on ControllerHandle. The Start() function is designed to be invoked from the EFI boot service ConnectController(). As a result, much of the error checking on the parameters to Start() has been moved into this common boot service. It is legal to call Start() from other locations, but the following calling restrictions must be followed or the system behavior will not be deterministic. 1. ControllerHandle must be a valid EFI_HANDLE. 2. If RemainingDevicePath is not NULL, then it must be a pointer to a naturally aligned <a class="el" href="../../df/d70/a00431.html">EFI_DEVICE_PATH_PROTOCOL</a>. 3. Prior to calling Start(), the Supported() function for the driver specified by This must have been called with the same calling parameters, and Supported() must have returned EFI_SUCCESS.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>This</em>&nbsp;</td><td>A pointer to the EFI_DRIVER_BINDING_PROTOCOL instance. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ControllerHandle</em>&nbsp;</td><td>The handle of the controller to start. This handle must support a protocol interface that supplies an I/O abstraction to the driver. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>RemainingDevicePath</em>&nbsp;</td><td>A pointer to the remaining portion of a device path. This parameter is ignored by device drivers, and is optional for bus drivers.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EFI_SUCCESS</em>&nbsp;</td><td>The device was started. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_DEVICE_ERROR</em>&nbsp;</td><td>The device could not be started due to a device error.Currently not implemented. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_OUT_OF_RESOURCES</em>&nbsp;</td><td>The request could not be completed due to a lack of resources. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Others</em>&nbsp;</td><td>The driver failded to start the device. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="909abfff42bf5f5342db312542b44be6"></a><!-- doxytag: member="DriverBinding.h::EFI_DRIVER_BINDING_STOP" ref="909abfff42bf5f5342db312542b44be6" args=")(IN EFI_DRIVER_BINDING_PROTOCOL *This, IN EFI_HANDLE ControllerHandle, IN UINTN NumberOfChildren, IN EFI_HANDLE *ChildHandleBuffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(EFIAPI * <a class="el" href="../../d3/dc7/a01170.html#909abfff42bf5f5342db312542b44be6">EFI_DRIVER_BINDING_STOP</a>)(IN <a class="el" href="../../db/db2/a00020.html">EFI_DRIVER_BINDING_PROTOCOL</a> *This, IN <a class="el" href="../../dd/d95/a01247.html#f943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ControllerHandle, IN <a class="el" href="../../d0/d90/a01059.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> NumberOfChildren, IN <a class="el" href="../../dd/d95/a01247.html#f943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> *ChildHandleBuffer)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stop this driver on ControllerHandle.<p>
Release the control of this controller and remove the IScsi functions. The Stop() function is designed to be invoked from the EFI boot service DisconnectController(). As a result, much of the error checking on the parameters to Stop() has been moved into this common boot service. It is legal to call Stop() from other locations, but the following calling restrictions must be followed or the system behavior will not be deterministic. 1. ControllerHandle must be a valid EFI_HANDLE that was used on a previous call to this same driver's Start() function. 2. The first NumberOfChildren handles of ChildHandleBuffer must all be a valid EFI_HANDLE. In addition, all of these handles must have been created in this driver's Start() function, and the Start() function must have called OpenProtocol() on ControllerHandle with an Attribute of EFI_OPEN_PROTOCOL_BY_CHILD_CONTROLLER.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>This</em>&nbsp;</td><td>A pointer to the EFI_DRIVER_BINDING_PROTOCOL instance. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ControllerHandle</em>&nbsp;</td><td>A handle to the device being stopped. The handle must support a bus specific I/O protocol for the driver to use to stop the device. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>NumberOfChildren</em>&nbsp;</td><td>The number of child device handles in ChildHandleBuffer.Not used. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ChildHandleBuffer</em>&nbsp;</td><td>An array of child handles to be freed. May be NULL if NumberOfChildren is 0.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EFI_SUCCESS</em>&nbsp;</td><td>The device was stopped. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_DEVICE_ERROR</em>&nbsp;</td><td>The device could not be stopped due to a device error. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="69fa28f889a84cd11d031137433c0e8b"></a><!-- doxytag: member="DriverBinding.h::EFI_DRIVER_BINDING_SUPPORTED" ref="69fa28f889a84cd11d031137433c0e8b" args=")(IN EFI_DRIVER_BINDING_PROTOCOL *This, IN EFI_HANDLE ControllerHandle, IN EFI_DEVICE_PATH_PROTOCOL *RemainingDevicePath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../dd/d95/a01247.html#5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(EFIAPI * <a class="el" href="../../d3/dc7/a01170.html#69fa28f889a84cd11d031137433c0e8b">EFI_DRIVER_BINDING_SUPPORTED</a>)(IN <a class="el" href="../../db/db2/a00020.html">EFI_DRIVER_BINDING_PROTOCOL</a> *This, IN <a class="el" href="../../dd/d95/a01247.html#f943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ControllerHandle, IN <a class="el" href="../../df/d70/a00431.html">EFI_DEVICE_PATH_PROTOCOL</a> *RemainingDevicePath)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tests to see if this driver supports a given controller. If a child device is provided, it further tests to see if this driver supports creating a handle for the specified child device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>This</em>&nbsp;</td><td>A pointer to the EFI_DRIVER_BINDING_PROTOCOL instance. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ControllerHandle</em>&nbsp;</td><td>The handle of the controller to test. This handle must support a protocol interface that supplies an I/O abstraction to the driver. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>RemainingDevicePath</em>&nbsp;</td><td>A pointer to the remaining portion of a device path. This parameter is ignored by device drivers, and is optional for bus drivers.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EFI_SUCCESS</em>&nbsp;</td><td>The device specified by ControllerHandle and RemainingDevicePath is supported by the driver specified by This. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_ALREADY_STARTED</em>&nbsp;</td><td>The device specified by ControllerHandle and RemainingDevicePath is already being managed by the driver specified by This. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_ACCESS_DENIED</em>&nbsp;</td><td>The device specified by ControllerHandle and RemainingDevicePath is already being managed by a different driver or an application that requires exclusive acces. Currently not implemented. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFI_UNSUPPORTED</em>&nbsp;</td><td>The device specified by ControllerHandle and RemainingDevicePath is not supported by the driver specified by This. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="28c565ce727b8661523ea1718e32ee8c"></a><!-- doxytag: member="DriverBinding.h::gEfiDriverBindingProtocolGuid" ref="28c565ce727b8661523ea1718e32ee8c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d87/a00689.html">EFI_GUID</a> <a class="el" href="../../d3/dc7/a01170.html#28c565ce727b8661523ea1718e32ee8c">gEfiDriverBindingProtocolGuid</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Aug 7 13:53:32 2009 for MdePkg[ALL] by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>
