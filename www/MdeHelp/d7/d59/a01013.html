<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>MdePkg[ALL]: MdePkg/Include/Library/CacheMaintenanceLib.h File Reference</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
<link href="../../tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="../../main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="../../annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="../../files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="../../globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>MdePkg/Include/Library/CacheMaintenanceLib.h File Reference</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID EFIAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/a01013.html#593515c631ff2101a4e73d70ab570c10">InvalidateInstructionCache</a> (VOID)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID *EFIAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/a01013.html#40cc3a9808435d1d32f82e5845101442">InvalidateInstructionCacheRange</a> (IN VOID *Address, IN <a class="el" href="../../d0/d2b/a01010.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> Length)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID EFIAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/a01013.html#6af0411d251bb35b2b3f0691840982b6">WriteBackInvalidateDataCache</a> (VOID)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID *EFIAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/a01013.html#e6543b300fd4b0bf65707f9ed85e6813">WriteBackInvalidateDataCacheRange</a> (IN VOID *Address, IN <a class="el" href="../../d0/d2b/a01010.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> Length)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID EFIAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/a01013.html#94526b8a771b8884af34de92a51a86ca">WriteBackDataCache</a> (VOID)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID *EFIAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/a01013.html#6a324975c05feb06a66ce22635d317ae">WriteBackDataCacheRange</a> (IN VOID *Address, IN <a class="el" href="../../d0/d2b/a01010.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> Length)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID EFIAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/a01013.html#1b0bc4aef810977c93f5c9ed639848e1">InvalidateDataCache</a> (VOID)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID *EFIAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/a01013.html#087f66459a5c5984e2fa4e33c793a9fb">InvalidateDataCacheRange</a> (IN VOID *Address, IN <a class="el" href="../../d0/d2b/a01010.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a> Length)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Provides services to maintain instruction and data caches.<p>
The Cache Maintenance Library provides abstractions for basic processor cache operations. It removes the need to use assembly in C code.<p>
Copyright (c) 2006 - 2008, Intel Corporation<br>
 All rights reserved. This program and the accompanying materials are licensed and made available under the terms and conditions of the BSD License which accompanies this distribution. The full text of the license may be found at <a href="http://opensource.org/licenses/bsd-license.php">http://opensource.org/licenses/bsd-license.php</a><p>
THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED. <hr><h2>Function Documentation</h2>
<a class="anchor" name="1b0bc4aef810977c93f5c9ed639848e1"></a><!-- doxytag: member="CacheMaintenanceLib.h::InvalidateDataCache" ref="1b0bc4aef810977c93f5c9ed639848e1" args="(VOID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID EFIAPI InvalidateDataCache           </td>
          <td>(</td>
          <td class="paramtype">VOID&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invalidates the entire data cache in cache coherency domain of the calling CPU.<p>
Invalidates the entire data cache in cache coherency domain of the calling CPU. This function must be used with care because dirty cache lines are not written back to system memory. It is typically used for cache diagnostics. If the CPU does not support invalidation of the entire data cache, then a write back and invalidate operation should be performed on the entire data cache. 
</div>
</div><p>
<a class="anchor" name="087f66459a5c5984e2fa4e33c793a9fb"></a><!-- doxytag: member="CacheMaintenanceLib.h::InvalidateDataCacheRange" ref="087f66459a5c5984e2fa4e33c793a9fb" args="(IN VOID *Address, IN UINTN Length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID* EFIAPI InvalidateDataCacheRange           </td>
          <td>(</td>
          <td class="paramtype">IN VOID *&nbsp;</td>
          <td class="paramname"> <em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="../../d0/d2b/a01010.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a>&nbsp;</td>
          <td class="paramname"> <em>Length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invalidates a range of data cache lines in the cache coherency domain of the calling CPU.<p>
Invalidates the data cache lines specified by Address and Length. If Address is not aligned on a cache line boundary, then entire data cache line containing Address is invalidated. If Address + Length is not aligned on a cache line boundary, then the entire data cache line containing Address + Length -1 is invalidated. This function must never invalidate any cache lines outside the specified range. If Length is 0, the no data cache lines are invalidated. Address is returned. This function must be used with care because dirty cache lines are not written back to system memory. It is typically used for cache diagnostics. If the CPU does not support invalidation of a data cache range, then a write back and invalidate operation should be performed on the data cache range.<p>
If Length is greater than (MAX_ADDRESS - Address + 1), then <a class="el" href="../../d1/dac/a01015.html#76b4aae2259415ea4b7e2c9b34ede0bb">ASSERT()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Address</em>&nbsp;</td><td>The base address of the data cache lines to invalidate. If the CPU is in a physical addressing mode, then Address is a physical address. If the CPU is in a virtual addressing mode, then Address is a virtual address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Length</em>&nbsp;</td><td>The number of bytes to invalidate from the data cache.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Address. </dd></dl>

</div>
</div><p>
<a class="anchor" name="593515c631ff2101a4e73d70ab570c10"></a><!-- doxytag: member="CacheMaintenanceLib.h::InvalidateInstructionCache" ref="593515c631ff2101a4e73d70ab570c10" args="(VOID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID EFIAPI InvalidateInstructionCache           </td>
          <td>(</td>
          <td class="paramtype">VOID&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invalidates the entire instruction cache in cache coherency domain of the calling CPU. 
</div>
</div><p>
<a class="anchor" name="40cc3a9808435d1d32f82e5845101442"></a><!-- doxytag: member="CacheMaintenanceLib.h::InvalidateInstructionCacheRange" ref="40cc3a9808435d1d32f82e5845101442" args="(IN VOID *Address, IN UINTN Length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID* EFIAPI InvalidateInstructionCacheRange           </td>
          <td>(</td>
          <td class="paramtype">IN VOID *&nbsp;</td>
          <td class="paramname"> <em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="../../d0/d2b/a01010.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a>&nbsp;</td>
          <td class="paramname"> <em>Length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invalidates a range of instruction cache lines in the cache coherency domain of the calling CPU.<p>
Invalidates the instruction cache lines specified by Address and Length. If Address is not aligned on a cache line boundary, then entire instruction cache line containing Address is invalidated. If Address + Length is not aligned on a cache line boundary, then the entire instruction cache line containing Address + Length -1 is invalidated. This function may choose to invalidate the entire instruction cache if that is more efficient than invalidating the specified range. If Length is 0, then no instruction cache lines are invalidated. Address is returned.<p>
If Length is greater than (MAX_ADDRESS - Address + 1), then <a class="el" href="../../d1/dac/a01015.html#76b4aae2259415ea4b7e2c9b34ede0bb">ASSERT()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Address</em>&nbsp;</td><td>The base address of the instruction cache lines to invalidate. If the CPU is in a physical addressing mode, then Address is a physical address. If the CPU is in a virtual addressing mode, then Address is a virtual address.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Length</em>&nbsp;</td><td>The number of bytes to invalidate from the instruction cache.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Address. </dd></dl>

</div>
</div><p>
<a class="anchor" name="94526b8a771b8884af34de92a51a86ca"></a><!-- doxytag: member="CacheMaintenanceLib.h::WriteBackDataCache" ref="94526b8a771b8884af34de92a51a86ca" args="(VOID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID EFIAPI WriteBackDataCache           </td>
          <td>(</td>
          <td class="paramtype">VOID&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes Back the entire data cache in cache coherency domain of the calling CPU.<p>
Writes Back the entire data cache in cache coherency domain of the calling CPU. This function guarantees that all dirty cache lines are written back to system memory. This function may also invalidate all the data cache lines in the cache coherency domain of the calling CPU. 
</div>
</div><p>
<a class="anchor" name="6a324975c05feb06a66ce22635d317ae"></a><!-- doxytag: member="CacheMaintenanceLib.h::WriteBackDataCacheRange" ref="6a324975c05feb06a66ce22635d317ae" args="(IN VOID *Address, IN UINTN Length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID* EFIAPI WriteBackDataCacheRange           </td>
          <td>(</td>
          <td class="paramtype">IN VOID *&nbsp;</td>
          <td class="paramname"> <em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="../../d0/d2b/a01010.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a>&nbsp;</td>
          <td class="paramname"> <em>Length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes Back a range of data cache lines in the cache coherency domain of the calling CPU.<p>
Writes Back the data cache lines specified by Address and Length. If Address is not aligned on a cache line boundary, then entire data cache line containing Address is written back. If Address + Length is not aligned on a cache line boundary, then the entire data cache line containing Address + Length -1 is written back. This function may choose to write back the entire data cache if that is more efficient than writing back the specified range. If Length is 0, then no data cache lines are written back. This function may also invalidate all the data cache lines in the specified range of the cache coherency domain of the calling CPU. Address is returned.<p>
If Length is greater than (MAX_ADDRESS - Address + 1), then <a class="el" href="../../d1/dac/a01015.html#76b4aae2259415ea4b7e2c9b34ede0bb">ASSERT()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Address</em>&nbsp;</td><td>The base address of the data cache lines to write back. If the CPU is in a physical addressing mode, then Address is a physical address. If the CPU is in a virtual addressing mode, then Address is a virtual address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Length</em>&nbsp;</td><td>The number of bytes to write back from the data cache.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Address of cache written in main memory. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6af0411d251bb35b2b3f0691840982b6"></a><!-- doxytag: member="CacheMaintenanceLib.h::WriteBackInvalidateDataCache" ref="6af0411d251bb35b2b3f0691840982b6" args="(VOID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID EFIAPI WriteBackInvalidateDataCache           </td>
          <td>(</td>
          <td class="paramtype">VOID&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes Back and Invalidates the entire data cache in cache coherency domain of the calling CPU.<p>
Writes Back and Invalidates the entire data cache in cache coherency domain of the calling CPU. This function guarantees that all dirty cache lines are written back to system memory, and also invalidates all the data cache lines in the cache coherency domain of the calling CPU. 
</div>
</div><p>
<a class="anchor" name="e6543b300fd4b0bf65707f9ed85e6813"></a><!-- doxytag: member="CacheMaintenanceLib.h::WriteBackInvalidateDataCacheRange" ref="e6543b300fd4b0bf65707f9ed85e6813" args="(IN VOID *Address, IN UINTN Length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID* EFIAPI WriteBackInvalidateDataCacheRange           </td>
          <td>(</td>
          <td class="paramtype">IN VOID *&nbsp;</td>
          <td class="paramname"> <em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="../../d0/d2b/a01010.html#4a2fc3b6f740e9cca9f895579c167560">UINTN</a>&nbsp;</td>
          <td class="paramname"> <em>Length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes Back and Invalidates a range of data cache lines in the cache coherency domain of the calling CPU.<p>
Writes Back and Invalidate the data cache lines specified by Address and Length. If Address is not aligned on a cache line boundary, then entire data cache line containing Address is written back and invalidated. If Address + Length is not aligned on a cache line boundary, then the entire data cache line containing Address + Length -1 is written back and invalidated. This function may choose to write back and invalidate the entire data cache if that is more efficient than writing back and invalidating the specified range. If Length is 0, then no data cache lines are written back and invalidated. Address is returned.<p>
If Length is greater than (MAX_ADDRESS - Address + 1), then <a class="el" href="../../d1/dac/a01015.html#76b4aae2259415ea4b7e2c9b34ede0bb">ASSERT()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Address</em>&nbsp;</td><td>The base address of the data cache lines to write back and invalidate. If the CPU is in a physical addressing mode, then Address is a physical address. If the CPU is in a virtual addressing mode, then Address is a virtual address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Length</em>&nbsp;</td><td>The number of bytes to write back and invalidate from the data cache.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Address of cache invalidation. </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Jun 10 17:24:08 2009 for MdePkg[ALL] by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>
